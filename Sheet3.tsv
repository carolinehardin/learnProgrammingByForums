<!-- SC_OFF --><div class="md"><p>I&#39;d been meaning to revisit <a href="https://docs.djangoproject.com/en/1.7/intro/tutorial01/">https://docs.djangoproject.com/en/1.7/intro/tutorial01/</a> ever since I got bored with it/got stuck on a stupid error the first time I was trying it out. To be fair, the &quot;official tutorial&quot; isn&#39;t a really good tutorial for true beginners to Django, IMO; luckily, I&#39;ve looked at a couple more Django tutorials since then, so I think I&#39;m ready to get back to now.</p> <p>Anyone who&#39;s interested in Django -- no matter your experience level with it -- can jump on. I&#39;ll be screen sharing my work so you can take a peek at Django if you&#39;re just curious, or you can do the tutorial with me at your own pace and we can instant message in the Google Hangout if questions come up.</p> <p>This will be a &quot;silent hangout&quot; -- i.e. work at your own pace, instant message only, no video/audio, screenshare if you want to.</p> <p>Let me know if you&#39;re interested here: <a href="http://hangouts.codebuddies.org/posts/bH4ueEF7Chh7cwQZo">http://hangouts.codebuddies.org/posts/bH4ueEF7Chh7cwQZo</a></p> </div>
<!-- SC_OFF --><div class="md"><p>So I&#39;ve got a goal of making a text adventure game, currently I&#39;ve got a window with a few baubles and such yet no actual gameplay. </p> <p>I need the entire interface to change the buttons and text in the fields when a button is pressed, how would I go about that?</p> </div>
<!-- SC_OFF --><div class="md"><p>I just started learning c++ and have been really wanting a mobile ide. I have been searching through the ide&#39;s available on android. But there are a lot and there is a lot of conflicting info, as always. Do you guys have a recommendation that is at least somewhat convenient to use on a s5 for now and better on a tablet later? I am fine buying it as long as it has things you can&#39;t get elsewhere, eg. Auto indent, efficient screen space use, compiling, ect.</p> </div>
<!-- SC_OFF --><div class="md"><p>Total noob here I just started coding like a week ago, anyway is there a way to have cases with multiple labels?</p> <p>ex: </p> <p>char blah=&quot; &quot;;</p> <p>switch(blah)</p> <p>{</p> <p>case &#39;kl&#39;:</p> <pre><code> [statement block] break; </code></pre> <p>case &#39;bn:</p> <pre><code> [another statement block] break; </code></pre> <p>default:</p> <pre><code> [default statement block] </code></pre> <p>}</p> <p>please dumb down your answer since I&#39;m new to c++ and all!! <strong>EDIT:</strong> I&#39;m using Turbo C++. </p> </div>
Yes, for example switch (foo) { case 'a': case 'b': /* a or b */ break; ]
<!-- SC_OFF --><div class="md"><p>Hello,</p> <p>I&#39;ve been learning HTML and CSS over the past few days through Codecademy and Treehouse and decided to use what I learned to work on my own side project (sort of). I&#39;m trying to make a simplified version of <a href="http://www.cyanogenmod.org/">CyanogenMod&#39;s front page</a> (minus the fancy scrolling bits for now). </p> <p>It&#39;s mostly done but I&#39;m having trouble with the footer. I didn&#39;t notice the issue until I tried to change the background to white and noticed that it only changes a thin white rectangle that sits between the bottom of my &lt;main&gt; element and the top of my &lt;footer&gt; element. </p> <p>It looks like this: <a href="http://i.imgur.com/RpTwmHn.png">http://i.imgur.com/RpTwmHn.png</a> (I made it red for emphasis)</p> <p><strong>Changing the margin, padding, width and height will affect the dimension of the rectangle, but the elements that are supposed to appear <em>inside</em> the rectangle instead appear <em>below</em> it.</strong></p> <p>I&#39;ve spent the last hour or so scouring my HTML and CSS files but I can&#39;t seem to figure out what is causing this. Unfortunately, since I don&#39;t have the slightest clue as to why this is happening, I can&#39;t do much to follow rule 5a in the sidebar. I&#39;ve tried commenting out various segments and inspecting the site in Chrome&#39;s dev tools but I can&#39;t seem to localize the problem. </p> <p>As such, I have little choice but to upload the HTML and CSS files in their entirety in the hopes that my mistake is obvious enough that it will stick out somehow. I&#39;ve tried to keep everything organized, commented and fairly straightforward, and the documents aren&#39;t that long, so hopefully it shouldn&#39;t be too bad. Any help would be greatly appreciated!</p> <p>JSFiddle link: <a href="http://jsfiddle.net/vvg5a09v/1/">http://jsfiddle.net/vvg5a09v/1/</a></p> <p>HTML only: <a href="http://pastebin.com/QxFYkGsa">http://pastebin.com/QxFYkGsa</a></p> <p>CSS only: <a href="http://pastebin.com/vTapQ5dh">http://pastebin.com/vTapQ5dh</a></p> <p>Thanks in advance.</p> <p>P.S. I know there are probably a lot of inconsistencies in terms of measurements and units (among other things), but I just sort of started hacking this together in-browser and didn&#39;t expect to be showing it to anyone. Sorry about that -- I&#39;m still learning.</p> </div>
It's because you have only floated elements inside that footer. A float is not in the normal &quot;flow&quot; of an element, the parent doesn't reserve space for it. Read more [here](http://www.w3.org/TR/CSS2/visuren.html#floats) or [here](http://css-tricks.com/all-about-floats/). A solution is to use [&quot;the clearfix hack&quot;](http://learnlayout.com/clearfix.html).
Thank you! That worked! But... why? And why is it called a hack?
<!-- SC_OFF --><div class="md"><p>Am I the only one that feels like the explanations of what the DOM is and does are somewhat more confusing than they ought to be? It&#39;s such a foundational concept, but I&#39;ve found it to be unreasonably difficult to wrap my head around due to unnecessarily technical language.</p> <p>&nbsp;</p> <p>I would love to see some attempts at an explanation that steer clear of technical jargon as much as possible while effectively conveying the concept.</p> <p>&nbsp;</p> <p>Hell, maybe we can start a dictionary of understandable explanations of core programming concepts!</p> </div>
DOM or the Document Object Model is basically a set of functions and objects you use to talk to the browser from JavaScript. That's really it. Some things that are included in DOM: * Functions for inspecting and changing the HTML document * XMLHttpRequest, used for fetching data without reloading the page * CSSOM, or the CSS Object Model, a part of DOM that lets you modify CSS values * Functions to listen for browser events, like clicks, scrolling, touch screen taps, etc. * Plus a lot more
This is actually pretty helpful. Is it right to say that the DOM is a piece of software built into the browser that reads and understands HTML, and provides the ability to manipulate the document using JavaScript as well as other programming languages? Does the DOM exist solely to allow scripting languages to interact with otherwise static documents?
I think the DOM is actually specified on a lower level as the data structures the browser should use to represent HTML documents. The specification also goes to define the JavaScript interface for it, which is what you see as the DOM functions etc. So basically the browser would have a parser which reads the HTML document and converts it into the correct data structures. You then get the ability to interact with that using the DOM functions in JavaScript.
Dunno. Can 'we'? Why don't you get started?
Yes, of course! Although, you might imagine that a definition coming from a person that doesn't fully understand the concept would be somewhat lacking. That said, here goes. The DOM is an API (another term I find unclear explanations of) that defines the structure of documents as well as how information included within them is accessed and manipulated. I think I can explain my problems with that kind of definition with an analogy to the way physics is often taught. Many teachers sling equations at students and say things like &quot;For this type of problem, use this equation. For that type, use that one! No cheat-sheets on the test!&quot; etc. On the other hand, every once in a while you find a teacher that focuses on the foundations. They explain *how* the equation works the way it does and *why* it was conceived of in the first place. They break down each variable and explain how it fits into the whole. They provide context and examples. Now all of a sudden you're no longer just memorizing equations but rather **understanding** them! I think the latter technique provides a lot more value, but it's pretty hard to come by. Particularly in the programming world it seems. If you'd like to take a stab at a better definition, I'd love to read it!
<!-- SC_OFF --><div class="md"><p>I took a course on Ruby last fall (at General Assembly here in NYC) and have been trying to improve my Ruby knowledge since, with what little free time I have when I&#39;m not at work. This usually entails working on exercises at <a href="/r/dailyprogrammer">/r/dailyprogrammer</a> and comparing my code to other Ruby submissions. I also took a VBA class since then, as my company was willing to pay for it. I&#39;ve been able to immediately apply my newfound VBA knowledge at work, where I&#39;ve automated several of my Excel tasks. </p> <p>However, I did not set out to become a Ruby/Rails developer. My <em>initial</em> intention in taking the Ruby class was to learn basic programming concepts, so that I could: 1) more easily learn VBA (for work, as I stated before) and so that I could 2) more easily learn Swift, as my <em>ultimate</em> goal was building iPhone apps (first as a hobby, and hopefully maybe become an iOs dev a few years down the line).</p> <p>Here&#39;s my dilemma -- everywhere I go (on reddit and stackoverflow), I see seasoned programmers advising and recommending that if you&#39;re starting out programming in general, you should stick to one language, build a pet project or two with it, and keep with it until you&#39;re no longer a newbie. Because of this, I am now reluctant to stick to my original plan of moving to Swift. <strong>Do you think I should keep working on Ruby</strong> and better my knowledge on it (I must admit I struggle trying to build a mere reddit bot), even though I don&#39;t have any intentions on graduating to Rails or even making simple Ruby programs? <strong>Or, should I just go ahead and start teaching myself Swift</strong>, where I&#39;ll have the opportunity to produce something tangible that I can proudly display simply by whipping out my phone (As opposed to firing up the command line on my laptop and showing off my latest word counting app)?</p> <p>I should note that I also work in the mobile advertising tech industry, so creating a smartphone app would be more familiar/relevant to me than, say, creating Ruby scripts and what not.</p> </div>
When you're at the bottom anywhere is up.
You could try this: http://www.rubymotion.com/
I'd say you should have started with swift to begin with. Go ahead and make the switch with the understanding that you are going to have to learn how to do a lot of things over again. Be careful to not let that discourage you.
Here is a coupon for a free swift course on udemy. https://www.udemy.com/building-innovative-ios-apps/?couponCode=FROMUDEMYSTUDIO
I'd agree that sticking to one language is good, but I would hesitate to say that switching is always wrong. I would switch to Swift now.
<!-- SC_OFF --><div class="md"><p>I am an undergraduate Electrical Engineering student. I am a fairly competent programmer, but my experience with GUIs is limited at best. I am involved in an undergraduate research project that needs this GUI. The gist of the project is that there is a piece of hardware that will receive data that consists of the location of a vehicle along a track. The software side of the project needs to receive the data from the hardware and display the location of the vehicle on the track, which basically needs to be a dot moving along the track, in real time using some type of graphical interface. The type of hardware that will be used is yet to be determined, so the form of the data it will send the location information remains to be seen. I have a little experience with Visual Basic (I hear it&#39;s fairly good for GUIs), however, the bulk of my experience is with C++ and Python. Basically the question is, what is the easiest way to implement a GUI that would fit this application? Where should I start in terms of learning how to implement GUIs of this sort? If more information is needed I&#39;ll do my best in the comments. Any and all assistance is greatly appreciated!</p> </div>
You should look into Qt. It's popular, and has c++ and python bindings.
Look at the TKinter stuff that comes with Python.
<!-- SC_OFF --><div class="md"><p>I&#39;ve been trying to find a starting point on what I need to learn to make something similar for a project, but I cant seem to find much from google.</p> <p>I&#39;m curious as to how user accounts work, especially on &quot;crowdfunding&quot; and e-commerce sites. </p> <p>For example, how does the database allow for user accounts, and how do they upload their campaigns? </p> <p>I&#39;m pretty competent with HTML, CSS and Javascript, and would like to learn some more about these things but don&#39;t know where to start. </p> </div>
You should try looking up database basics before trying to come up figure out how specific type of sites work. You may want to look into MySQL for a free database. You will also want to look into a backend programming language so you can interact with the database. PHP is a popular language so you can find a bunch of resources about it.
<!-- SC_OFF --><div class="md"><p>Hey, im a rookie programmer and I have only really ever made scripts. Recently I started some Physics coursework about finding the resistivity from a thick and thin wire of Nichrome, so I made a Phyton program to do calculations for me.</p> <p>The program works as I want it to, but I have been told there are a lot of beginner mistakes in the style and that its not very efficient. </p> <p>Im wondering if anyone here can point out obvious things that I can do to improve how I code, as im not sure what these beginner mistakes would be in the first place.</p> <p><a href="http://ideone.com/6OR7kH">http://ideone.com/6OR7kH</a></p> <p>Thanks.</p> </div>
Variable names are the biggest part of proper coding. The reason people shy away from long(er) names is because of the time commitment involved in typing them out. With that said, if you are thinking about continuing with python, look into IPython and numpy. IPython is an interactive environment that features auto-complete and a host of other efficiency features. Numpy is a package for high-speed numerical computations. If you truly want efficiency, you can't beat a package written primarily in C and Fortran. As for coding style, that come with time as you react to your own and other people's lack of code readability. Efficiency also comes from reading other people's code and copying modalities. All in all, patience and practice are the remedies you're looking for. And the right coding environment.
* Avoid uninformative variables (x and t) * There might be a bug in your program on line 31. Did you mean x+=5? * Regarding efficiency, I am not sure. Most of the calculations are straight forward and there are no loops. If you want to be ultra-pedantic, you can simplify some of the math so there are fewer calculations the computer is running.
Thanks a lot, fixed the bug and changed the variable names.
Aside from what others have said already here's my first glance. You make 3 different lists for different calculations, all the same size. Consider converting those into a single dictionary and referencing the dictionary values instead. Break up your code into functions, then call the functions. The function names help self document the code if done correctly and assist in 'modulariz-ing' your code if you will.
Line 26 should either print something or return something. I don't think returning the result of print does anything useful. Line 30: google how python ifs and ors work. This is obviously wrong and easy to see how to fix if you look. Line 38 has way too many parens. Wtf are you doing wrapping everything with parens everywhere? Overall not too bad.
Thanks for the advice, I just kind of assumed 'or' would be what it sounds like tbh. For line 38, its just kind of my preference, for some reason I feel its more likely to work if I put a bracket for almost all separate calculation, however if it makes it harder to read I can understand why I should remove them.
<!-- SC_OFF --><div class="md"><p>Using github web interface and netbeans git integration i am able to do use it for my needs. Should i learn the commands as a CS student who aims to work on big 4 or startups?</p> <p>yeah, hit that downvote button, woohoo</p> </div>
I would say yes. There will be some things that are just easier to do over the command line, but more than anything you don't want to pigeonhole yourself to GUIs that may or may not exist on systems you'll be working on. Also, it's pretty easy-- you only ever really use 5 or 6 commands about 99% of the time.
thanks!
I use `log``push``pull``add .``commit` That's about it.
Lots of companies use Git but don't use GitHub, and also lots of companies use Git but don't use NetBeans. Those are great reasons to learn how to use Git itself and not rely on those integrations. Also, Git is so ubiquitous that if someone says they ran a certain Git command you'll want to know what they're talking about. That said, there's nothing wrong with learning the everyday commands (git pull, git merge / git rebase, git commit, git checkout) and then using a GUI for more obscure stuff.
Yes, for multiple reasons: 1. With GUI-based setups, you're limited to the tools on hand. If they become outdated, buggy, or do not work on some new platform then you're SOL. Terminals on the other hand are ubiquitous to every OS and are very solid. 2. Personally speaking I usually work much faster typing in command line than using GUI tools. 3. The time investment is almost minimal, esp if you already understand the basics of how Git actually works. Similarly, it's also better to invest a little time and know this even if you don't use it, than to need to use it and not know it. EDIT: Also an FYI, there's a user here on /r/learnprogramming who posted two Git tutorials recently
If you're really looking for a top job yes - you can't rely on IDEs to hide the magic from you.
This is personal opinion, but I highly recommend learning the git command line work flow. I started out experimenting with gui clients but found that the CLI worked better for me. So, get yourself accustomed to typing commands and set up aliases too. It'll pay off!
<!-- SC_OFF --><div class="md"><p>This is part PSA, but also part rant. I&#39;ve seen lots of people work on projects who don&#39;t understand where their favorite language ends &amp; where the database needs to begin. In fact I work with a commercial software which - on a daily basis - pays for this mistake. </p> <p>You all know what a database is, but most people will treat a database as their bucket for information. Beyond that they will overlook <em>key features</em> that a database can &amp; must do. I think it would help to cover some basics.</p> <p>1) <strong>Timing</strong>: If you want a process to run once per hour, you do not just schedule it to run once per hour. What you actually do is to create a table in your database which stores a log of when the task ran. Then you query that table to see if it should run again. If yes, then run, if not, then continue. The database is then responsible not just for logging but also the timing of your app. This also means that if you have multiple instances of the software, they can collaborate without overlapping. If your software crashes or is otherwise unable to connect to complete a task, it can do so at the next available moment. Not doing this way is (IMHO) a huge mistake.</p> <p>2) <strong>Organization</strong>: Today your project is as big as it is &amp; your processes revolve around the scope you&#39;ve set out. Tomorrow your project might grow. This means tracking new relationships, deprecating old ones, or changing content types. In larger projects, you might have different developers with varying skillsets, styles &amp; ideas. You may not be the best manager on the planet or you might see the value in letting people bring to the table what they will. This happens all the time &amp; it does not need to be a stumbling block. Though it is usually more like a death sentence. If you were to use the wonderful views &amp; stored procedures rather than hard coding select &amp; insert statements, you would be able to change everything from the source rather than chasing it down in every piece of code you have. A strict MVC design wouldn&#39;t hurt, but in it&#39;s absence, just adopting these practices are essential. It would also allow you to provide free range for your team without sacrificing the integrity of your data. Until you&#39;ve spent years cleaning up data, you won&#39;t understand how powerful that statement is, but take my word for it.</p> <p>There is a pretty long list to continue, but from these two key bullet points, you can extract quite a bit. Happy hacking!</p> </div>
It's about how, and more importantly, when do I use a database to store my info.
I am left wondering the type of software you might write which wouldn't depend on a database. Anything small may not necessarily require one
&gt; am left wondering the type of software you might write which wouldn't depend on a database. Anything small may not necessarily require one Anything CPU heavy is rather likely to not depend on a database. We have a bunch of 'tools' that just do analysis on files on a HDFS filesystem for example.
&gt; Not doing this way is (IMHO) a huge mistake. That's WAY to generic. There's tons of situations where a simple cron-job would suffice. &gt; If you were to use the wonderful views &amp; stored procedures rather than hard coding select &amp; insert statements, you would be able to change everything from the source rather than chasing it down in every piece of code you have. Again: completely depends on the situation. Heck; it depends on the database you use. In general you should stay clear from using stored procedures: you're moving logic into a layer that should not have any. If your code is duplicating functionality moving it to the database isn't the solution. Frankly: you sound like an over-eager DBA. Those types always want to have code living in 'their' database instead of where it should be.
&gt; Frankly: you sound like an over-eager DBA. Those types always want to have code living in 'their' database instead of where it should be. Possibly. Mostly it's that I spent 4 years working with a company that makes a series of completely irreconcilable mistakes centered around these issues. Then when I come to the forums I find that we as a community are not teaching budding developers where to make the distinction. Though, seeing it objectively, the thing that is undeniably the solution to my problem may not be an optimal standard.
&gt; Then when I come to the forums I find that we as a community are not teaching budding developers where to make the distinction. Because this distinction isn't as clear cut as you pretend it is. Junior developers talk in absolute like these. Senior developers ask tons and tons of questions. Every single application has different requirements. The project I'm working on actually uses 3 completely different databases and will very likely use a 4th soon. A bunch of very senior devs (8 in total) make these decisions based on a lot of discussions.
It seems as if you're doing the same thing that you're accusing me of doing. The topic of conversation was to know which options are available &amp; to decide when they should be used. Instead you've focused on the stored procedures, assumed that it was an absolution rather than an option &amp; then fit it in within the narrow confines of what it means to be you specifically as you're doing this job. I understand where the criticism comes from and I'm open to it, but you're taking the conversation in a course that makes it impossible for me to answer because I'm not you.
&gt; The topic of conversation was to know which options are available Good luck with that. There's tons if different types of databases each with their pro's and cons. &gt; Instead you've focused on the stored procedures Uhm. No? I didn't even mention them in the post you replied to?
&gt; Good luck with that. There's tons if different types of databases each with their pro's and cons. Yes. And each and every one of them is more than just a bucket to store information. My point was not DBMS specific. &gt; Uhm. No? I didn't even mention them in the post you replied to? In a conversation a context begins to develop. So when you say &quot;*Because this distinction isn't as clear cut as you pretend it is*&quot; it refers to something that came before it. As a result my response is to the context and not exclusively the words that appeared in the latest post.
<!-- SC_OFF --><div class="md"><p>I have a project for C programming using if-else switches. Heres the criteria: Your code will generate a random number from 1 to 6 inclusive Use a switch statement to print the word the number is: One if number is 1 etc. It will use nested if – else statements to print “1 or 2”, “3 or 4” or “5 or 6” depending on the random number’s value No &amp;&amp; and or || Boolean operators, you must correctly use if – else with only 3 if-else statements Variable for number must be named N Almost every time you run the program must be a different random number. Not 100% sure where to start. Help??</p> </div>
The criteria literally states what you need to do and have. What don't you understand?
I'm not sure what commands I should be using to generate the random numbers.
http://lmgtfy.com/?q=c+random
Ok, so lets break this down. Your code has to do three things: 1) Generate a random number 2) Print the number in words form via switch 3) Using If/Else statements print &quot;1 or 2&quot; ect. We can start anywhere, which of the three do you want to tackle first?
generating the random number. What I've got written so far is: int N; N = rand(6); printf(&quot;%d&quot;, N); getchar(); return 0; } With out all the extra spaces. I should also note that it just prints 41 on the screen.
set rand seed to Time(NULL) and do: N = ((rand() % 6) + 1) to get a random number from 1-6
As others have mentioned, you need to seed rand with the time. That will take care of #1. On to #2. Do you know how a switch statement works? Can you try and make a variable &quot;string wordToOutput&quot; and try and set it to the right string based on the number? Shame on whoever down voted you for not having a perfect solution with your first try.
If I'm understanding whatyou're saying, it should be switch(N) case 1 printf(&quot;one&quot;) break; Is that what you're talking about?
Yep thats right, so finish it out with more cases for the other numbers.
Well I finished that. I think I can get the if else statements down, those seem pretty easy to me.
This will be good practice on using documentation. Go look up how rand() works. You're currently giving it the same seed value each time, so you are getting the same number each time. You want to look in to rand() and srand().
<!-- SC_OFF --><div class="md"><p>I am an avid reader of <a href="/r/learnprogramming">/r/learnprogramming</a> as sometimes it provides some good links about interesting topics. But this is more like a hate-post so sorry in advance :).</p> <p><strong>There is no easy way</strong>. There&#39;s no easy way to learn math, play guitar, make music or draw. Nor should there be an easy way, it&#39;s a long journey.</p> <p>I see a lot of &quot;Watch me as I do this python bot&quot; or &quot;this is my HTML/CSS programming tutorial for beginners&quot;.</p> <p>I am not a mod of this subreddit, nothing similar. But I hate when I see these click baits so beginners would upvote and believe that once they will see this video or finish this course they will be able to do something. The truth is, after all these proclaimed lessons, you will be able to do exactly nothing because there&#39;s no easy way. Yes you will learn almost nothing and will be able to do nothing.</p> <p>There are a lot of advices from more experienced people to learn data structures, algorithms, C(yes C), C++, Python. And it shouldn&#39;t be easy and it&#39;s the right way. It should be hard and that&#39;s where the fun begins. Once you realize that something was hard and now looks easy you can reflect on yourself in the past and see how much you have improved and this industry pays not because you watched 10 hours of &quot;HTML PROGRAMMING GURU VIDEO&quot;.</p> <p>Enrolling in 5 different programming courses on coursera or edx will kinda help if you do all the homework without cheating and form my experience it&#39;s impossible to take more than 1 serious course online if you have a job. Don&#39;t kid yourself.</p> <p>I am kinda sad that this subreddit like a year ago seemed quite interesting with interesting links about interesting topics and now became &quot;learn python in 5minutes&quot; &quot;learn to program like a start with CSS&quot;.</p> <p>There&#39;s no easy way nor should there be.</p> </div>
&gt; There's no easy way nor should there be. In that case, you're completely in the wrong place. This is a teaching subreddit. It's supposed to make things easier! Just because you or I needed to suffer while learning doesn't mean the others need to go through this. Yes, there's lots of crap resources, /u/htuhola says &gt; Many of the teaching videos seem to be done by people who just learned the thing they try to teach. Lots of the 'lessons' are of form: &quot;Hey see what I can do!&quot; and he has a point. I think a lot of it is related to the Dunning-Kruger effect, I noticed that I had suffered from this myself before I even knew this had a name. After you get some basics down, you feel like the world lies at your feet, you've mastered everything, but you don't realize your own ignorance, you think you're finally in a position to teach yourself. Just look at those tutorials not as a tutorial for others, but as a learning experience for its author. Give feedback to that. Make it clear that you don't think something is a good teaching resource. Also make it clear that this isn't something personal or something to be discouraged by, but a natural thing for someone to do.
&gt;I think a lot of it is related to the Dunning-Kruger effect, I noticed &gt;that I had suffered from this myself before I even knew this had a &gt;name. After you get some basics down, you feel like the world lies &gt;at your feet, you've mastered everything, but you don't realize &gt;your own ignorance, you think you're finally in a position to teach &gt;yourself. What would you do to get rid of this effect?
1) Set a task for yourself. &quot;Make a Tetris clone&quot; &quot;Make a WYSIWYG electronic science fair submission web site&quot; &quot;Make an inventory management system&quot; 2) Try it. Effect gone, enjoy the feelings of inadequacy and ignorance
it's best to let the effect linger, in my opinion. Teaching is one of the best ways to learn, and everyone needs the occasional humbling experience to go with it. ;)
Are you offended because of the promises, or because of the ineffectiveness of the lessons? Many of the teaching videos seem to be done by people who just learned the thing they try to teach. Lots of the 'lessons' are of form: &quot;Hey see what I can do!&quot; I think it's all cool. But yes they could use descriptive titles instead of trying to clickbait with something lame. Doing descriptive titles is harder and presents the true value of things though...
I am kinda offended by lame lessons. They seems to me like karma pits. You don't know the topic yet you want some karma points or good responses so you produce one more great HTML programming tutorial :). Don't want to throw exact URLs to those because it would be unethical. I agree with you that it seems that a lot of lessons are made by those who just got the topic. That time watching useless lessons can be really used more practical.
I think the rubber hits the road in this subreddit with the actual answering of questions from student programmers. That is to say, you're looking for the goldmine of good links about learning how to program, but I don't think that is where this subreddit shines. It's more the direct access between students and experts that I think is important.
&gt; I am kinda offended by lame lessons. Those who are easily offended deserve to be offended.
&gt; I am kinda offended by lame lessons. They seems to me like karma pits. Who cares. There's tons of karma grabs here (The &quot;I'm going to start an open-source project where any beginner can join&quot;-type you hear nothing from anymore for example). There's also tons of spammers that just want to draw traffic to their crappy blog. That's not gonna change ever.
I've been coming to this subreddit pretty consistently for over two years now, and honestly it's the same it's always been. Good content ebbs and flows, the same ten questions asked every other day, yada yada. Not really any different now than it was back then.
&gt; I am kinda sad that this subreddit like a year ago seemed quite interesting with interesting links about interesting topics Such as? It's a sub where beginners ask for help. If you want interesting stuff about programming in general there's the appropriate sub for that.
I hesitated a bit about commenting, other people said 90% of what I'll say. But I suspect that &quot;Watch me as I do this python bot&quot; thread could be created by me(I was building a bot for /r/WatchPeopleCode, a subreddit about live coding that I moderate). I am not though, it could be other thread I saw here and I wasn't trying to click-bait, and I actually was building the bot, although I ended up fixing a bunch of related, but different things. The stream was an experiment for me, plus building a bot for live streaming subreddit and live streaming the process sounded like a cool idea. I do agree with you that learning involves a certain degree of pain, but it probably can't be always easy, but I definitely think it could be made easier(which is this subreddit is for). I disagree that it is always bad idea to watch a few videos. There is no &quot;either-or&quot; situation here. Also posting here for karma points is pointless, self posts don't give you any karma. :)
Hmm, at least the videos spark some interests for some to indulge in the programming world and test the water, although videos like these need to be thrown into /r/WatchPeopleCode.
I agree about /r/WatchPeopleCode videos should be put there. Also must agree that videos are often much better probably because people who put that much effort really know their topic and don't want just quick karma points :).
<!-- SC_OFF --><div class="md"><p>I&#39;m an Android developer (published my first app recently) diving into webdev. Is there something I should know before I start? I&#39;m planning on dedicating full 6 months on learning web development(I&#39;m a student, so that&#39;s one semester) . I didn&#39;t quite research on where/how to start because I&#39;ve seen people either recommending odinproject or codecademy (which gets me bored, because I already have some prior experience). Is there anything else I should be looking at? I used hundreds o different resources when I was learning the Android framework, and I think I&#39;d like to take a similar approach for web development. I&#39;m trying to learn the full stack curriculum.</p> <p>Also, I haven&#39;t done anything web related as an Android developer.</p> <p>What are some Github repos following good practices that I should be referring to, for web development? </p> </div>
I also published an app recently on Android, and also done a little web dev. The question is which end are you looking to learn? Front-end, client-side, browser-based apps, or back-end, server-side web sites, or both?
I want to learn both. I like spending time learning, so I'd really like to gain some knowledge of both front-end, and back-end.
For front-end you have tutorials on JS on various sites (w3schools comes to mind), and some books (such as JavaScript Patterns by Stoyan Stefanov). But really, in my opinion the easiest way to learn to make browser apps is to have a set goal in mind; I want to make a page that shows certain tweets from twitter. So you would start by reading about HTML and structuring the page, then you might look at CSS and style it. After that you read about JavaScript and create some dynamic text, then you look at the Twitter API and read about XmlHttpRequest and so on. For backend things get a little complex. There are many different things that can be done. You need to set up a server first (IIS on Windows, Apache/nginx/other on Linux). Then you need to configure it to serve the pages you want. Perhaps add PHP integration. You can pick any language you want (thanks to CGI). You might want some database connections as well. These are very specific to the language you choose to use. So you basically need to have some specific idea in mind as to what you want to make.
That's a very clear and concise explanation, thanks! Having a goal set in mind, and just working on it is what actually sped up my Android learning. I want to do the same for web development, and having an idea in mind is already a start. Also, I really hate markup and styling languages. If there's one field of CS/IT/programming that I hate; it's markup and styling languages. Even when working on my Android app, I had to drag my self through working on XML, but I think I did pretty well, and got some good reviews for the design and layout. What do you suggest I do to speed up the learning of HTML and CSS? Would looking at webpages' source code be helpful, or should I be picking up a book and skimming through? I guess back-end is what I'm really interested in, but I'd like to learn front-end as well.
I think following the HTML and CSS tutorials on [http://www.w3schools.com] should be enough. Very short, very simple, there's not much to it. There's also HTML5Boilerplate.com to save you from many browser quirks.
Just gave w3schools a shot. Seems nice. To the point. Will check out HTML5Boilerplate.com as well. Thanks!
I'm an Android and iOS dev. My boss isn't particularly tech savvy and web dev is pretty much the same thing isn't it? Gang pressed into web dev for the last few months here are some things to consider: * Pick up an MVC framework for the backend. I considered Cake PHP and ASP.NET but went with Ruby on Rails in the end and I'm thrilled with the choice. MVC does a lot of the heavy lifting for you but comes at a price. You spend most of your time learning the conventions and best practices with the language and syntax coming as an ancillary skill. Point in fact, I'm very inexperienced with Ruby as a language but can develop web apps confidently with Rails. * Coming from a statically typed language this type of work sucks. There is little in the way of syntax error highlighting, code completion or useful stack traces. Automated testing fills these gaps. If you don't know how to test you can't do back end web dev. * CSS is a fickle beast. I picked up Twitter bootstrap for the front end but there are others like skeleton or boilerplate. Learn a responsive grid based layout system. You should be able to use divs to say this bit goes here and that bit goes there with confidence. * Learn the RESTful architecture - GET, PUT, POST, DELETE uri endpoints for CRUD - create, retrieve, update and delete in the database
Thanks! I have a question - &gt;If you don't know how to test you can't do back end web dev. What kind of tests do you recommend? Are there testing frameworks like there are for Android?
<!-- SC_OFF --><div class="md"><p>I&#39;m a senior in math with a 3.96 GPA. I have four years of research experience where I had to &quot;program&quot; (I use this term lightly) in mathematica. I’ve also had to use Matlab in some of my classes I&#39;m pursuing my PhD next year in applied math. If I could go back, I would have double majored in computer science. </p> <p>I’ve taken two course in C++ for elective credit. I understand the fundamentals. I know a lot about the math behind computer science (and can learn more easily). I understand complexity, runtime, etc. I know algorithms on a very sophisticated theoretical level. </p> <p>More importantly, I feel like the design process of coding software is incredibly similar to writing a math proof. It requires perfect attention to detail, and doing it right is very different from doing it eloquently and efficiently. Shortening a proof or problem with a relevant theorem is like using a package or boiler plate. I could go on.</p> <p>It seemed logical for the next step to be a summer internship. But I’ve gotten two automatic rejections (within 5 minutes) from companies that I’m assuming automatically screen me out because I don’t have a major in {Electrical Engineering, Computer Science, …}. It’s never listed as an immediate requirement, so I just keep wasting my time. I can’t upload a sample of my code. I can’t give an interview. I can only stare at a rejection from a do not reply email. </p> <p>Am I wrong in thinking that I’m at least enough of an asset to be given a shot? Sure, I only know a little bit compared to senior CS majors, but surely there’s use for a competent mathematician? I’m not looking for a glorious job at google. But I’m creative, motivated, and have research experience. Surely there’s some internship that could make use of someone who may need catching up on programming but can work on making advanced algorithms or doing sophisticated mathy work in xyz software. It seems like it could be a symbiotic relationship. </p> <p>Nope. Everything seems like “B.S. In computer science or equivalent or relevant work experience required.” I will keep learning. But I can’t help thinking there’s a glassdoor: “relevant work experience.” </p> <p>Tl;dr Competent math major with the mindset of a programmer. Keep getting automated rejections for summer internships in software engineering. Are there any internships you know of for a math major with beginner-level coding skills where I can hone my abilities as a programmer? If not, what should I do to get these opportunities in the following summers while I pursue my PhD. I dream of one day working in silicon valley using math to design extremely efficient, cutting edge software. </p> </div>
Not exactly /r/learnprogramming topic, probably /r/cscareerquestions is better. Either way, recruiters are usually the ones that screen you; without being super awesome, lacking a {Computer Engineering, Software Engineering, Computer Science} degree only means you are already behind someone with similar skills as you, but has (or is working towards) the related degree. (Source: me, sitting in Silicon Valley as an intern as part of my CS degree, sitting by recruiters at work) However, all is not lost because you do realize that actually being able to program is really important; getting the interview is easier than doing the interview! So start honing your skills with some neat projects first. Luckily, programming work experience doesn't necessarily mean at a job. You can (and should) show off your own projects/hobbies. Contribute to an open source project, whatever to show you know what you're doing. Second, go apply to more entry level jobs. Actually, just apply to everything that you can remotely do (ie, have some skill in at least, maybe not something you absolutely do not have any knowledge in). I've applied to hundreds of interviews, gotten instantly rejected by most, bombed a dozen interviews and yet I still found a job.
Very good advice, thank you. I would like to take part in open-source projects, and I certainly realize I need to learn more. I guess I was just hoping that I could find something that makes use of my math knowledge and pays me based on that while they train me in programming. Maybe that was just a pipe dream. Sorry about posting in the wrong place, I'll check out the other sub!
Don't sweat it. Let me get some basic facts out of the way. Your skills and knowledge are applicable and employable. All the time you spent scratching your head figuring out how the hell that proof makes sense was worth it. With that out of the way... what tech companies have you applied at? If you don't want to give names then give size. It may be that your cover letter is too general; they're looking for people who can solve very specific problems. Be succinct: *here's your problems, I've done my homework on you guys, here's how I can help you*. Please don't re-use generic phrasing on your cover letter. It's okay for a resume (resumes in tech should be chock-full of buzzwords), but cover letters should be tailored to that particular company's problem domain(s). Finally, don't be afraid to overstate your expertise. You seem like you can handle it. No relevant software engineering experience? Fuck that. You've got *years* on you writing research-oriented, cutting-edge software. Or something like that. You're ambitious and you want to get a PhD and apply your knowledge on something useful. tl;dr KEEP APPLYING. FAKE IT UNTIL YOU MAKE IT. YOU'RE GETTING REJECTED DUE TO BUZZWORD DEFICIENCY. COVER LETTERS MATTER. UPDATE YOUR LINKEDIN.
Thank you for the response: Most google/apple internships are closed now. I've really just been googling &quot;software engineering&quot; or &quot;math software engineering&quot; etc and seeing what looks interesting or what has requirements that aren't explicitly beyond me. I'm worried I might have missed the boat on beginner-level internships. Ugh, if I could go back 3 years, I would have done computer science instead of a stupid business minor. I'm still applying to mathworks and a few other internships. Hopefully the people at Matlab are sympathetic. This is one of the ones that was particularly frustrating: http://connect.att.jobs/plano/college/jobid6026656-student-intern-technical-i-big-data-jobs It was actually posted on my university's job search website, too. So I spent hours tailoring my resume, then filled out a very cookie-cutter online application with no room for a cover letter or anything but a resume, transcript, and list of prior work experience. IMMEDIATE rejection as in within 2 minutes. Waste of my damn time. I was beyond pissed. How else could I have been screened out besides my major? The only holistic part of my application was my resume (where I mentioned software I knew, etc) and work experience (worked with numerics, handled date on different mathematical structures, mentored younger undergraduates, etc). I just can't express how annoying it is to spend hours fine tuning an application to have it denied by a computer program (the irony of which is not lost on me). Is there a list of absolutely mandatory buzzwords I need? Anyway, I'm open to any tech companies, big or small. I just need a summer job that works me to the bone for barely enough pay to feed and house myself so that I can work my way up. I'll keep throwing resumes out there I guess until it works.
Don't spend too much time tailoring your resume. That's what the cover letter is for. Just some buzzwords of the top of my head, I apologize for this not being comprehensive: **Python**, Go, **NoSQL**, mongoDB, Neo4j, FoundationDB, **MapReduce**, Hadoop, **SQL**, Linux, Matlab, JavaScript, ES6, node.js, **Java**, C++ Ones in bold are hot or just timeless... pick and choose 1 or 2 languages and challenge yourself to learn them over a weekend. The hurdle is the syntax, but you're smart, you can handle it. Some &quot;non-specific buzzwords&quot; you can sprinkle like sugar: design patterns, **algorithms**, problem solving (solving problems), mathematical perspective, **big data**, **deep learning** (I'm interested in the applications of deep learning, convolutional neural networks, etc). You majored in math, but you have 3~ years background in writing *software* for mathematical purposes. Frame your education and experience that way. Don't put shit on there you can't back up, but on the other hand don't undersell your confidence in learning these technologies over a weekend. Finally, don't get bent out of shape over these rejections. Nobody is making light of your hard work or intelligence. Act professionally, respectfully and constantly attempt to network with your peers, advisors, professors, and professional contacts. The nice thing is you're still in school pursuing a PhD. Spend the next few years trying to nab a job at Amazon, Yahoo, Google, Apple, or other mid to large sized tech companies. Don't waste your time with a start-up unless they're willing to pay you very good money. You should know how much you're worth. Google and Apple only hires top talent, or highly specialized people. I've been rejected a few times. I still apply from time to time (just for fun).
Thank you so much for this advice! I studied java a while ago, so I will refresh my knowledge of it. In your mind, what do you think is a reasonable level of knowledge in a programming language to obtain an entry-level job? I can create a function class, do for loops, declare variables, etc. This is what I mean by fundamentals. Learning syntax is doable, and of course I can always get better with any language, but what is a baseline of skill I should be aiming for? Is there some kind of set of basic things I should be able to do in order to consider myself competent (conversationally fluent maybe?) in a language? Or is this a question that can only be answered with &quot;depends&quot;?
Jargon. Programming has a lot of jargon. Speaking the language, throwing the appropriate idioms gets a person a long way to being &quot;accepted&quot;. Every language has its own idioms. It's not that bad, especially for a person with a strong math background. You want to get a handle on scope. Each language has its own idiosyncratic scoping rules. Debugging is an art mastered through the pain of experience. Ever read a seemingly correct proof of how 1 = 2 or FLT and you're sure something is off but you can't really pin down *where*? Sometimes debugging can feel like that. You can never be conversationally fluent in something unless you *converse* using it every day. Whether it's at work using it for 8 hours a day, or via practicing on your own time. But the key advantage you have is that math is like the ancestor of every programming language. Every programming language should bear a vague resemblance to what you know already. The last thing I want to add is that the level of programming chops that is expected of you depends on where you're talking about. At Amazon, they screen candidates based on if they can think about problems logically and solve them algorithmically. Having coding skills is a plus. Writing beautiful code is a plus. All that can be trained. But it's hard to train someone to be smarter. Just keep that in mind when you're applying to places... tl;dr Don't sweat it, just practice programming once in a while. One day the language will 'click' like figuring out a particularly obstinate proof. And keep applying to places.
<!-- SC_OFF --><div class="md"><p>Hi, so I&#39;m a complete beginner. Literally started reading this textbook (C Primer Plus) today. I&#39;m on chapter 2 now and the text is asking me to copy and paste its code into the compiler to see what the program does. So I did this, (Pelles C) and I saved and went to compile, but it immediately spits out at me a whole laundry list of errors which don&#39;t seem to make any sense. I think I&#39;m doing something wrong here. Can anyone help?</p> </div>
&gt; Can anyone help? Not with the vague information you've given. If you are trying to compile code, then post the code you are trying to compile. If you are getting error messages, then post the error messages you are getting. Read the sidebar for guidelines about posting code.
Yeah I read the sidebar. I'm not sure if I'm allowed to just copy and paste code or not. And I'm not sure what I'm doing with those tools at the bottom there. But oh well, I guess I'll give it a try.
here is the code from the textbook: #include &lt;stdio.h&gt; int main(void) /* a simple program */ { int num; /* define a variable called num */ num = 1; /* assign a value to num */ printf(“I am a simple “); /* use the printf() function */ printf(“computer.\n”); printf(“My favorite number is %d because it is first.\n”,num); return 0; } . . . and here are the errors it's giving me http://i.imgur.com/Txj0dT3.png
You're not using proper quotation marks - you used ““, while it should be &quot;&quot;.
The quotation marks are funky. Fix those quotes with the standard ones: &quot;
As /u/adrian17 and /u/knight-of-lambda have pointed out, you have the wrong quotation marks. Use a real text editor to edit code, not a word processor.
<!-- SC_OFF --><div class="md"><p>The relationship between the people who deal with software and the people who deal with hardware is symbiotic. Be helpful and respectful to everyone, especially the guys who keep your servers up. Just thought this would be a good reminder because I&#39;m starting to see more and more programmers looking down on the IT workers. I&#39;ve done both and trust me, you both need each other.</p> </div>
Well, tbh you need to respect everyone.
Except Chad. We all bitch about Chad.
tl;dr Don't shit where you eat/don't bite the hand that feeds you.
<!-- SC_OFF --><div class="md"><p>Programming: Principles and Practice using C++.</p> <p>Chapter 3: objects, types, and values. does not cover if statements until 4.</p> <p>Chapter 3 exercises: <a href="http://www.stroustrup.com/Programming/Solutions/Ch3.html">http://www.stroustrup.com/Programming/Solutions/Ch3.html</a></p> <p>Given the information in chapter 3 you cannot accomplish most of those exercises... You don&#39;t even learn anything (well barely) about if statements. In fact chapter 3 references chapter 4 when it shows an example that has an if statement. So, am I expected to jump between chapters?</p> <p>Even more annoying is the book doesn&#39;t go over the exercises. There&#39;s no reference or anything telling me where to go. I had to go to the website and discover that on my own. </p> <p>If you notice the exercise solutions tell you things are explained in later chapters... Why am I doing an exercise of things that&#39;s in several chapters down the road...</p> <p>Point. I don&#39;t see how this is a beginners book. If I hadn&#39;t started with other resources like youtube. I&#39;d have shot myself in the face trying to learn from this book and the way it&#39;s laid out.</p> <p>note: using ebook version.</p> <p>I have common sense and the ability to figure things out fairly quickly. But, if this is the recommended book to start out and it costs nearly $50.</p> <p>Is this a way to weed out the undedicated? or what?</p> <p>I am actually on chapter 9. But, I had to rant about this as I just tried to send a copy of my ebook to a friend (&quot;shhh&quot;) and they wanted to slap me cause they spent a while on that chapter reading it multiple times thinking they missed something as to why they couldn&#39;t do those exercises.</p> <p>I try to think of reasons they&#39;d do that. Maybe, just maybe you&#39;re meant to want to break your face off your keyboard because you have no clue what your doing in those exercises and as you read the next chapter you&#39;re like #@)#$#)&amp;@#... Thus you retain the information a bit better, go back and ace those exercises?</p> <p>It comes to show that even the best resources we have are still subpar what they could be.</p> </div>
To be fair, the author does provide code snippets which (I think) clearly illustrate the if statement. Its a great book, but it is challenging. I finished it 3 years ago, and still have many of the exercise solutions. PM me if you ever get really stuck. Also, its alright to step away from the book for a few days. Personally, I gave up on the book 2-3 times before getting through it. Worth it.
They barely cover anything about the if statements in the 3rd chapter. Yes, it looks obvious if you have some idea of them. But, to a complete beginner they will need more depth on it as they provide in chapter 4. But, my point is simply they are giving you exercising that request things you don't really learn for another few chapters. (In the exercise it uses if else in the solution, you do NOT see those at all in chapter 3.) I think they are just out of place. I didn't notice it at first because as I said I did not soley go to the book. But, I used other online resources and the book. For now I'm hoping to find another resource. I'm trying to learn C++ and I'm in no place to teach. My neighbor and friend is to far for my internet and does't have his own. So, he needs books. I had another tablet and let him use my ebooks. So, I'm looking for something that is more in-place for a complete beginner. With things like that being out of place it's bound to frustrate a lot of people. Most people will consider themselves stuck and throw the book down. Instead of going back to it later.
To top this off the constexpr use in this book is not supported by codeblocks nightly or VS 2013. What the hell...
I've never consulted a book for programming help. It's always been try and fail, and then Google how to fix that fail, or bug a professor about it. But mostly Google the problems, and hope someone helps. If books are not your thing, you do not have to use them.
Seems like without college, books are my only option for updated and &quot;good&quot; programming methods. Most stuff on youtube is outdated. Same with a lot of other documentation online. I can learn from books, challengingly. But, finding the right resource is always the hard part. I'm just trying to figure out why they have this book organized as it is. It seems pretty crappy for fifty bucks.
<!-- SC_OFF --><div class="md"><p>Hi guys,</p> <p>I&#39;m starting a small business and want to build PM software custom built for my services - I have the design in mind as I know the work flow etc.</p> <p>It will involve a database of clients, which in turn have jobs allocated to them, which in turn will be able to generate and email different types of simple reporting, proposals and invoicing.</p> <p>Where do i start?!?!?!?</p> </div>
PS - web-based and used in field on smart phones for easy reporting etc
Do you know how to write software? That's where you start. Then choose the backend and database you want to use. Popular options are C#, java, php, python, and ruby. From there it's just about getting everything wired together and executing your plan.
Start with buying QuickBooks / QB mobile and then do your custom software on the side. Starting your new business relying on software you have yet to write sounds like a recipe for disaster.
Sorry, I didn't explain properly - business is up and running and doesn't rely on PM software...I see a way of making it more efficient without jumping between databases, word docs etc etc
<!-- SC_OFF --><div class="md"><p>So I&#39;ve occasionally, upon trying to join an open source project, been told that the best way to get started was to write documentation for it. In fact, that if you&#39;re new you are a great person to write documentation because you know what is confusing.</p> <p>I&#39;ve been programming for about 8 years now and thought I would be able to do this by the time I graduated uni or had a few years in industry. That&#39;s happened and I&#39;ve never actually been able to do this successfully and always ended up walking away in frustration. Has anyone ever written good documentation for an unfamiliar project? How do you go about quickly getting an understanding of the conceptual structure of the project from a high level?</p> <p>I&#39;m starting to think that this advice is misguided and like saying &quot;the best person to draw a map of a city is someone who&#39;s never been there&quot;.</p> </div>
&gt; Has anyone ever written good documentation for an unfamiliar project? You are right, it is unheard-of thing. So you simply need to get acquainted with the project first. Download it, install, try, discover its features, think of what it may lack etc. If it is a library - think of what you learned while playing with it and try to write at least short essay. Then you will be able to see better what more you need to know about this project and needed documentation to deepen and extend your work. There could be no more detailed advice. Projects are too different. If possible try to see what scraps of documentation your chosen project already have. &amp;nbsp; &gt; I'm starting to think that this advice is misguided and like saying &quot;the best person to draw a map of a city is someone who's never been there&quot;. No, you are wrong, I'm afraid. Topographer or scout does this on regular basis. However, I know another way, though probably it is not easier. You should download a project, try to play with it and find some small bugs or things which you can improve in some obvious way. Fix them and make pull-request. I recently wrote few more thoughts about joining open-source projects in my blog - [here](http://rodiongork.tumblr.com/post/106239453568/how-to-contribute-to-opensource-project).
Somebody that is experienced with the project will miss things he or she considers obvious. However as a brand new set of eyes, if you start using a project (as a developer or user) without any knowledge about it, will be able to find out what is missing from the current documentation and probably experience the easy mistakes to make. Obviously there must be some documentation already present for this to be achievable. Making mistakes and not really knowing about some of the bits and pieces is fine, there should be some kind of review process for the documentation as well. Whenever I had to read new documentation for projects I was already familiar with, it was very easy and took little time to find and correct any mistake that it might have had.
The reason that writing documentation is a good idea is because: 1. You must question what code does. How does it handle the input? Are there edge cases (and how are they handled)? What is the intent of the code? Does it do what the name implies? 2. You can work through the code in a systematic approach. This can allow you to discover things you would miss and can avoid misconceptions. 3. Understanding code requires following it all over. You don't look at a single function and know what it does. Instead, you look at it, then look at the functions it uses, and so on, working your way through the dependencies. This lets you understand how the code fits together.
<!-- SC_OFF --><div class="md"><p>I&#39;ve decided that I wanted to use Python as my first language to dive into. I&#39;ve read a couple times that Python is too &quot;bare&quot; and doesn&#39;t show all of the bits and pieces that I&#39;ll use in the more complicated languages later on. Python by nature is one of the &quot;cleanest&quot; languages but I fear that by the time I get to say, Java, I won&#39;t know enough to write that type of code cleanly.</p> <p>Some have suggested that I start with C because it forces you to write efficient code as well as optimization techniques. Then again I&#39;ve also heard that it&#39;s a bad thing to optimize too early in the process.</p> <p>I have a copy of the book &quot;Clean Code: A Handbook of Agile Software Craftsmanship&quot; and I was wondering if I should read this while learning Python rather than take the C → Python route.</p> <p>I just want to learn how to code as cleanly as possible via the most time effective method. If it does turn out that I should go with C though it wouldn&#39;t be the end of the world. Thank you.</p> </div>
Starting with Python makes sense. Also, don't worry about this too much. There is no wrong answer. It's more important to get started actually learning.
I think that you've fallen into the trap a lot of beginners make -- you've made the incorrect assumption that your choice of first language actually matters in the long run. My first language was a horrendous combination of basic and C and assembly that ran on graphing calculators. It was shockingly medieval -- you were permitted only 27 (global) variables, no locals, you had no real functions (only goto), and no stack traces. If your code had an error, it would crash and just wipe the entire memory of the device. Even though my first exposure to CS was this medieval, it didn't end up making any noticeable impact. I'm currently fluent in many different languages (including C and Python), have interned for several major tech companies, and am teaching a class on programming right now. Rather, what matters is _minimizing friction_, _increasing velocity_, and _building momentum_. Programming is a constant process of learning and discovery. This is something that's true whether or not you've been coding for only 10 hours or if you've been programming for 10 years. As a result, the most important thing you can do is to do whatever it takes to minimize friction and set you on a path where you're constantly learning. If you start off constantly learning, that builds momentum -- you get into the habit of constantly coding, learning, and improving. It's this momentum that's by far the most important thing to cultivate, not where you start and what your first language learned is. Even if you happen to start in a shitty place (as I did), you can quickly catch up as long as you're able to build up and maintain that momentum. --- The reason why many people recommend Python is because it has very little friction. The language is very simple, so you can progress to making programs and learning about the heart of programming that much faster, Python requires very little setup on all major operating systems, and there are tons of resources on Python available so looking for resources and help is very easy. The main advantage learning C will give you is that it'll give you a sense of how the machine works on a lower level, and how to manually manage memory and still write good code. For a beginner, this is probably a distraction -- learning C requires you to (1) learn C syntax, (2) learn how memory works and how to manage it, and (3) learn how to program, and all three of these things are non-trivial. If you learn Python first, you'll have already learned (3), and learning (1) will be much easier since you'll see echos and similarities between Python and C syntax. --- That said, there are some people who just prefer having a more rigorous backing and having everything explained from the ground up, even if it's harder. I know one or two people who tried Python and wasn't able to get anywhere. When they switched to C or C++, something clicked -- they preferred learning from the absolute basic principles, wanted to understand how everything ultimately related back to the machine, and couldn't tolerate some of the handwaving Python does. I even know one person who wasn't able to &quot;get&quot; C but was an absolute wizard at assembly. I personally think she was definitely a fluke (for most people, learning assembly as their first language is a horrible idea) but it happens. If you're one of those people, and find Python dissatisfying for some reason you can't quite pin down, then C or some other language might legitimately be a better option. Try it, and see what happens. Again, you want to pick a language that you're comfortable with and enjoy learning. Minimize friction. Build momentum. --- If you have a mentor or a community who's willing to help you learn coding, then I have different advice -- disregard everything that we've been saying, and just learn whatever language he or she or the community is most comfortable with. The main reason why I was able to learn programming and CS despite starting with a horrible language with a huge amount of friction was because I was able to find a very small, kind, and smart community who also worked with the same language. They were very tolerant of beginners and stupid questions, and a lot of them were also new to coding, so we were able to learn and grow from one another. I owe a lot to them. Having a good teacher trumps everything -- they can guide you through rough patches and point you in the right direction, and can eliminate friction by a ludicrous amount. Similarly, if you find a really good book or online resource, and you enjoy the author's writing style, then consider learning whatever language that book/resource happens to be teaching. Remember, you're constantly learning -- there's always time in the future to circle back and apply what you learned to other languages. The things you learn while programming compound and stack. If I spend 5 years working in Java, for example, I'm going to still be able to apply the bulk of my knowledge to other languages. The details of the language don't matter -- what _does_ matter is the heart and core and essence of programming. And _that_ is something that you can learn no matter what language you pick.
Refactored the words right out of my mouth.
A couple comments: * The clean code book is mostly written with java examples. If you don't know much about programming reading a book with a different language than the one your learning (python) would be confusing. * This isn't really a book for learning how to code. It's a book to help people that know how to code code better. * Python and java really aren't too dissimilar. Going from python to C would be much more difficult.
&gt;Some have suggested that I start with C because it forces you to write efficient code as well as optimization techniques. C doesn't force you to do anything. C lets you do whatever the hell you want. You can write things as inefficiently as you want in C. One time I saw someone allocate a static array for 100,000 items for a search program. You wouldn't even consider that in a higher level language. C gives you the ability to make thing more efficient and to optimize things. It teaches you the building blocks. Until you spend a month or two learning, you won't know the difference at all. &gt; I just want to learn how to code as cleanly as possible via the most time effective method. Why? You don't even know how to code yet. You've written 10 lines on the theory of coding, but 0 lines of code. That would be like someone commenting on the best wood to build with who has 0 carpentry experience. You need to fix this imbalance and stop planning. It's not enough to stare up the steps... you have to step up the stairs.
&gt; Why? You don't even know how to code yet. That's why I'm asking specifically which route would prepare me best to code efficiently. If I have should start with C then I'll start with C. If Python is sufficient then I'll start with Python. There's 2 sets of stairs here. If you don't have a suggestion on which to take that's fine, but spare me the patronization in the meantime.
I'm not trying to patronize you. I'm suggesting that your whole premise is slowing your learning. Why do you want to code efficiently? Because you heard somewhere that's important? You need to just dive in and get your hands dirty. There is NO best language out there. C and Python each have there own strengths and weaknesses. TL;DR Whatever language you can most quickly write and execute a &quot;Hello World&quot; program is the one I suggest.
&gt; Why do you want to code efficiently? Because you heard somewhere that's important? I've heard several times that it's one of the most important things &amp; that's why I bought the book in the OP. It's also stats like [these (from :20-1:09)](https://www.youtube.com/watch?v=VRQn2utaaJw) on [hack.pledge\(\)](https://hackpledge.org/). How it was told to me was that if I learned how to code efficiently early on I'd kill two birds with one stone. Maybe this isn't feasible &amp; I'm just gullible enough to believe it, but that's why I'm here.
What most people are getting at here is that you kinda need to learn software development before you can truly grasp the 'why' of clean coding practices. I think it's a smart idea to be aware of these things when you're first diving in, but keep them as a secondary/back of the mind thing. As for what language, it honestly doesn't matter, choose whatever you like. Most importantly if it's fun programming in it, you'll likely learn faster and enjoy the process more (with that in mind I'd recommend Python, and this is coming from a C programmer). The thing about C is that since it is such a small, low level language, learning C kind of entails learning the underlying concepts of stack frames, heap management, various parts of linking and compiling etc etc. Which is not bad, it simply is a lot to bite off at once. Something like Python lets you jump directly into the world of Computer Science (read problem solving, data structures, algorithms etc) without having to tackle the underlying stuff at the same time.
You could start learning with just about any language and no one here can say exactly which first language is perfect for you, only you can answer that and even there, you can't really step back in time and start from scratch with a different first language You could conceivably learn two or more languages concurrently but that's probably going to be confusing. I second the others here who suggest starting out with Python first. That will help teach how to solve programming problems without delving too deeply into low level details. From there, you could try C when you're ready to explore those lower level details. BTW, Python itself is written in C and you could easily bridge the Python-C gap by writing your own Python module in C.
I thought about learning both at the same time but I'm not sure how that would pan out. If the consensus is that I won't miss out on anything with Python then that'll do; that was the plan from the start until people got in my ear telling me C would be better for the aforementioned reasons.
Start with python. C will be too daunting and slow (to learn) as a newbie. Personally I learnt python for a year before starting Java, and I can easily transfer my knowledge to write clean object oriented code with ease.
As a newbie that has been learning programming in C for 4 months aprox. only, I suggest you to not worry about optimization for now. You'll have to learn a lot of things before even starting to think about optimizing (I still barely haven't), which doesn't mean you shouldn't care about writing clean code.
You seem to be getting your info from questionable sources or not interpreting or understanding it very well. I would just stick with Python and make some real progress first.
I've read articles like [this](http://lifehacker.com/the-case-for-learning-c-as-your-first-programming-langu-1682070792) (not the end all be all source, I'm well aware of that) and several posts on sites like StackOverflow that corroborate the same story. Then again I've read plenty that contradict those same stories, hence me asking which you would suggest. Note that I'm not saying **any** of the info is gospel; I'm just saying it's what I heard. Right or wrong, it's just what I heard.
I find that article (or rather, [the article it's copying](http://www.evanmiller.org/you-cant-dig-upwards.html)) kinda silly; and I know C and don't particularly like Python. Lots of it's assertions sound kinda nice in a romantic &quot;C is hardcore&quot; sense, but none of them seemed backed up with anything concrete. I remember as a kid doing lots of silly stuff with a variety of languages like Javascript or Basic or PHP. None of it ever prevented me from learning C or C++ or Assembly or HDL, and if I was a kid today I'd be thrilled to start out with writing a rude twitter-bot. ___ The main conceptual hurdle with learning C after different languages would probably be pointers and manual memory management. But this stuff is hard if you learn C first too, and just comes down to practice, so that alone doesn't seem like a super compelling reason.
What I said still stands. Do with it what you will.
Well I appreciate you pointing out the inaccuracies &amp; providing more legitimacy /s. FWIW I wasn't the one who downvoted you.
I don't care who downvotes. This isn't a middle school popularity contest for me. If you want to ignore what I say about your understanding and show how smart your are with your sarcasm, go right ahead.
Looks like you're downvoting in retaliation that's why I brought it up, seems pretty petty to me. And I was being sarcastic because you said I was having trouble interpreting the info I was getting. Nothing specifically, no setting the record straight so I could have the correct info. If that was supposed to be helpful I don't see how.
Best not to think too much about one or two downvotes on this subreddit. Sometimes stuff will just get downvoted seemingly randomly.
Everything in your post seemed questionable, except of course your statement about you having a book. What is there to even set straight?
&gt; Everything in your post seemed questionable *** &gt; What is there to even set straight? *** &gt; Everything I guess I should remind you that you voluntarily came into this thread so there's no excuse about how much of a labor it would be when it was on your own volition. But honestly I don't feel like talking in circles. Just leave it alone.
I like how you appear to quote an extra &quot;Everything&quot; that I didn't even say. I'm not even making any excuses. &quot;Bare&quot; is meaningless in the way you used it, so there's no effort required here, there's nothing else to set straight. You're the one who's too lazy to ask intelligent questions here, instead just whining when I explain how meaningless what you originally said was.
&gt; I like how you appear to quote an extra &quot;Everything&quot; that I didn't even say. I quoted that because in the first sentence you answer your own question. What's there to set straight? Well, you said everything. Not that hard to comprehend. &gt; &quot;Bare&quot; is meaningless in the way you used it, so there's no effort required here, there's nothing else to set straight. Python's syntax is simpler than C's. Bare means basic / simple. Again, not that hard to comprehend. &gt; You're the one who's too lazy to ask intelligent questions here Ironic seeing as how you're too lazy to explain yourself &amp; yet you keep insisting that you did lol &gt; instead just whining when I explain how meaningless what you originally said was. Except you didn't explain anything, you just said &quot;my point still stands.&quot; You've yet to get specific besides my incorrect (which was actually correct) usage of the word bare. This is where it ends. If you've got nothing better to do then go do that somewhere else with someone else.
Focus on the &quot;how do I make that work&quot; part rather than the &quot;how do I make it look nice&quot; part. Once you have a decend understanding of coding you can still improve your style. That said: This is **not** a permission to just ignore style at all. So, python (from what little I know about it) is a good choice. On the matter of C: C is a shit language to start with. It's **very powerful but hard to learn**. It is definitly not suitable as a first language. When you have trouble understanding the basics you don't want to deal with complicated stuff like manual memory management as well. Python will do lots of things for you. That will make learning easier. Also Java, C#, Ruby, PHP, JavaScript, ... will have similar features. So you will not miss out on important knowledge.
Yeah I know I have to get the ball rolling first. For me it's just whether or not it'd be worthwhile to learn C now rather than later since I've been told that it's easier to transition to other languages if you have a strong grasp of C. But if you're saying I won't miss out on anything with Python I guess that doesn't really matter.
Nowadays more languages you'll use will have things in common with Python than C, though C will teach you what is going on underneath. The thing is that the most important thing to learn is the algorithms - when you're worrying about memory and pointers all the time this could get in the way easily. I started with Java, and as a first language I think it's very good as it's stricter than Ruby or Python, and it's powerful. If the strict choice is Python or C I'd say 100% use Python, though personally I think Ruby or Java are good starters.
<!-- SC_OFF --><div class="md"><p>title says it. i can paste my code if needed</p> <p>Code: </p> <h1>include &lt;iostream&gt;</h1> <h1>include &lt;fstream&gt;</h1> <h1>include &lt;string&gt;</h1> <h1>include &lt;cstdlib&gt;</h1> <p>using namespace std;</p> <p>int countNumbers(ifstream&amp;); // counts the number of items in a file</p> <p>int* loadData (ifstream&amp;, int&amp;); // load and return an array</p> <p>void getName(string<em>&amp;, string</em>&amp;, ifstream&amp;, int&amp;);</p> <p>const string filename = &quot;D:\testData.txt&quot;;</p> <p>int main() {</p> <pre><code>ifstream myFile; int numberOfLines; string *first = NULL, *last = NULL; myFile.open(filename.c_str()); if(myFile) { numberOfLines = countNumbers(myFile); cout &lt;&lt; &quot;Number of lines in the file is &quot; &lt;&lt; numberOfLines &lt;&lt; endl; getName(first, last, myFile, numberOfLines); myFile.close(); for (int i = 0; i &lt; numberOfLines; i++) cout &lt;&lt; first[i] &lt;&lt; &quot; &quot; &lt;&lt; last[i] &lt;&lt; endl; } else cout &lt;&lt; &quot;ERROR: Could not open file.&quot; &lt;&lt; endl; </code></pre> <p>return 0;</p> <p>}</p> <p>int countNumbers(ifstream &amp;inputfile)// counts the number of inputs in the file { int x = 0; string temp;</p> <pre><code>while( getline(inputfile, temp)) // reads the file into the temporary spot { // inputfile &gt;&gt; temp; used to read the file we wanted white space to end it x++; // adds 1 to the amount of things there are in the file } //cout &lt;&lt; &quot;There are counted items in file&quot; &lt;&lt; endl; inputfile.clear(); // resets the file so we can read it again later inputfile.seekg(0, ios::beg); return x; </code></pre> <p>}</p> <p>int* loadData(ifstream &amp;inputfile, int &amp;kounter)</p> <p>{</p> <pre><code>int * pointToArray; kounter = countNumbers(inputfile); pointToArray = new int[kounter]; for ( int i = 0; i &lt;= kounter; i++) inputfile &gt;&gt; pointToArray[i]; return pointToArray; </code></pre> <p>}</p> <p>void getName (string* &amp;firstName, string* &amp;lastName, ifstream &amp;inputFile, int &amp;kounter)// sorts the data by average</p> <p>{</p> <pre><code>kounter = countNumbers(inputFile);// gets how big my array has to be firstName = new string [kounter];// loads the first array of strings with fist name lastName = new string [kounter];// loads the array for last names int temp; // temp data storing for(int i = 0; i&lt;kounter; i++) { inputFile &gt;&gt; lastName[i] &gt;&gt; firstName[i]; // gets the arrays loaded for(int j=0; j&lt;5; j++) { inputFile &gt;&gt; temp;// gets the numbers } } //cout &lt;&lt; &quot;output in function&quot; &lt;&lt; endl; //for(int a = 0; a &lt; kounter; a++) // cout &lt;&lt; lastName[a] &lt;&lt; firstName[a] &lt;&lt; endl; //cout &lt;&lt; &quot;End of Function&quot; &lt;&lt; endl; </code></pre> <p>}</p> <p>My question is how would i start to sort the names by last name? my teacher wants us to use a selection sort</p> </div>
Always post code. And always say what _specific_ problem(s) you are having with it.
&gt;My question is how would i start to sort the names by last name? my teacher wants us to use a selection sort I would probably google selection sort. The top result [here](http://en.wikipedia.org/wiki/Selection_sort)
I did that but i cannot figure out how to use this for letters =\
when you say letters, do you mean characters or strings?
strings, as in the array for last name is filled with strings of last names and i need to sort those by the first letter of their last name
the string class you are using respects the '&lt;' operator. a string is said to be *less than* another string if it would come first lexicographically (basically alphabetical for your purposes) The code given in the wiki article should probably work provided you use your variable names instead. EDIT: given that you are sorting by last name, but you want the first and last names to remain consistent, every time you swap two last names as part of your sort, you probably want swap the corresponding first names as well.
thats exactly what i needed, thanks a ton man
<!-- SC_OFF --><div class="md"><p>I&#39;ve decided to learn C# to start with instead of Python. I will also be learning HTML5 and CSS3 thanks to /prettycoolguy13 and his udemy course. So what advice can you help me to know that isn&#39;t covered in the FAQ? Are there recommendations for websites or resources? Anything specific I need to download or stay away from downloading? Please help me /learnprogramming you are my <del>only hope!</del> first resource. Fill me with your knowledge.</p> </div>
Visual Studio obviously, if you are doing C#. A good text editor (Notepad++, Sublime Text, there are others). Chrome and Firefox if you are doing web stuff. (Heck, even if you don't) Personally I love having Total Commander for file management. Git for version control (or whichever other VCS you're using if you have a good reason to not use git). Other things, just install them as you need them.
If you're a university student you can get Resharper for free, which helps out a ton.
<!-- SC_OFF --><div class="md"><p>I&#39;ve been learning how to program for a while now in Python and Ruby and I&#39;m going to start learning C++ for a robotics club at my high school. I&#39;ve been using GitHub&#39;s Atom as my text editor of choice for a while now and absolutely love it. However, is there a way to turn it into a serviceable C++ IDE with extensions? I&#39;m asking this because I really like Atom and I don&#39;t really want to switch to something like Eclipse. Thanks!</p> </div>
I don't know much about Atom in particular, but most decent text editors have plugins that provide semantic completion and syntax checking for languages like C/C++. I think your success will depend on the robotics API. If there is an eclipse plugin specifically designed for this robotics API, then you should probably just use it. P.S. Visual Studio may change your opinion on IDEs.
you can get language support in atom for c/c++ (quick google search led me to [here](https://github.com/atom/language-c) ). I don't think atom has a compiler extension, however you could just have a terminal open and swap to it to compile.
I'd figure I would just ask here instead of making a new thread. Whenever I save my program in Atom, I try to compile it with gcc but it doesn't seem to actually reflect the changes. For example, if I change a line of code and save it in atom, or Sublime for that matter, if i reopen the same file in vim or nano it seems to be the older version of that file. Does anyone know what I'm talking about? I'm having trouble trying to google the problem as it's kind of hard to explain. I'm on Mac OS X Yosemite.
Hmm, the only thing I can think of is when Atom has a lot of extensions and your system has it's ram delegated to other tasks, Atom can have some latency issues. When you're trying to compile, Atom might still be saving. Try closing some browser tabs and removing non-essential extensions.
You...could. But the better question you might want to ask is if you should. Yes, you'd rather stick with Atom, but sometimes it's better to use a chef's knife than a swiss army knife for a given task. There are a number of C++ IDEs out there that have integrated compiling, debugging, code completion, and other tools that will make life far easier. I'd bite the bullet and try to find one that will work for you.
Honestly, yes you can, but if you can get your hands on Visual Studio I think you'd be much better off. It's ease of use when it comes to C++ is great, and its what I would recommend.
<!-- SC_OFF --><div class="md"><p>I need to learn PHP for internship which I will be starting in about 4 months.</p> <p>I have a good understanding of java, C# and OOP and I need to know what I can do to become a competent php programmer for when I start.</p> <p>I don&#39;t really want to read a php book due to having to read through everything I already know such as data types, methods, arrays etc.</p> <p>What would be the best way to go about this? -Make a dynamic website linking to a database? -Just get stuck into a php book(already have 2 sitting here) and get a grasp for the language?</p> <p>All advice welcome.</p> </div>
You should ask which framework they're currently using. start diving into that. There's also [http://www.phptherightway.com/](http://www.phptherightway.com/). check out php's namespaces and autoloading. Since you already have java and C# everything else is pretty much google/stackoverflow. &quot;how to do (java like) in php&quot;
&gt; I don't really want to read a php book I started learning PHP just by googling &quot;PHP tutorial&quot; - after practicing about two hours I was ready to give my first lesson in PHP (that is why I needed to learn it) - ha-ha! I'd say language gives easy learning curve so you may work with tutorials and examples instead of books. You may also try to solve in PHP these few practical exercises dedicated to basics of web-dev, which I announced recently: http://www.reddit.com/r/learnprogramming/comments/2tyz31/start_learning_webdevelopment_right_now_with_5/ (P.S. yes it is my site and it is also written in PHP - though I'm mainly occupied as java developer - so you see, I did some progress after few first steps)
I actually bookmarked your post the other day because I was planning on doing it. PHP just looks ugly compared with Java or C# but I will just have to overcome that. Thanks for the advice.
&gt; PHP just looks ugly I also thought so initially. Later I've found that modern PHP borrowed many useful features (including OOP) from Java / C# in almost the same form. So I believe it would be easy enough for you to learn it. Just make sure you follow tutorials on PHP 5+ or even 5.3+ (with namespaces) to avoid wasting time on obsolete constructs. After you'll get acquainted with basic usage and web-pages principles - try frameworks like CakePHP or better Symfony 2. This will be quite important for your internship or further work. Also, unlike C# and Java it is a scripting language so it often gives greater flexibility, which is nice for smaller projects. Of course in larger ones you want more strictness, especially if you work in team.
try [codeacademy](http://www.codecademy.com/)
<!-- SC_OFF --><div class="md"><p>Hi, I am 2 months into programming (c#/xaml), trying to write simple app as &quot;helper&quot; for one of my boardgames (user input, mostly numbers -&gt; calculation -&gt; display result on screen). I learned a lot doing this, each time new problems arise there is tutorial for that somewhere. </p> <p>My problem is that I feel like I am jumping around when writing things. And I am rewriting a lot because of this. And I am rolling around a lot to look back and forth on things I already written and I have to check what they are doing. And that switching between xaml and code-behind.... </p> <p>So how do you work with your code? You do half of UI where user write input, then write the business and than finish second half of UI - displaying results? Or just ignore UI first, define something like &quot;temporary variables&quot; instead of user input to make your code work and deal with UI last? </p> <p>Or for example lets say I am writing one class which has some math in it. Do you first define all variables and than write your formula and than return result? Or do you start with formula and create variables as you go? I am rolling mouse wheel around even in simple class with all my comments around. </p> <p>Thanks</p> </div>
There's no best way to do it. Jumping around between a few source files is totally common, and changing your mind halfway and having to rewrite it a few times is also totally normal. I've been programming for 20 years and I still do this all the time - because when I start implementing something, even if I've thought about it and planned it well, I still can't anticipate all of the details that will arise. The only advice I have is to try to break the problem down into small, *complete* steps, and check in each step into version control. So if you're writing hundreds of lines of code before committing to git (or whatever you prefer), consider trying to make the simplest change that actually compiles, then committing that, then adding the next piece, and so on. It will make backtracking and rewriting much easier.
I'm don't think I have enough to say to justify a new comment, so I'll try to complement this one. There is a few thing you can do before actually coding, for example, if you're already going to code a class, I assume you already know why this class has to exist, what it is going to do and how it integrates into the whole system, knowing that then you can plan out the &quot;major&quot; methods of that class, that are the most important ones and the ones that justify the class existence. If you know the methods, you can know, for each method, at least what it returns, if it returns and/or what it does, maybe you can already tell what parameters that method needs to do its job, now, maybe you got a value that it's going to get used a lot in most methods, why not make it a class variable then? In every method the best thing I can tell you is to initialize every variable close to where it's used, you don't initialize every iteration counter for your for loops in the beginning of the method do you? You do it right at the start of the loop, because thats where it makes sense to do so. So it's the same for most variables, keep them close to where they are used, and later when you need to debug it it's going to be easier to know what that variable does.
The two usual ways to program (I would assume there are only two!) would be either &quot;top down&quot;, or &quot;bottom up&quot;. Of course, you can flip between them as you develop but both have their own advantages and you will probably stick to mostly one. Top down means you create you are planning out from the top down, that is, what function(s) you want to call and get your final answers from. In your case, user input functions and some function that takes user input and calls calculate() or something. You're designing from general functions, to specific functions. Top down is a little easier to conceptualize but subject to more changes as you realize things aren't what you might have expected. Bottom up is thinking about the models and basic functions that you will obviously need and working towards the general functions. This is harder to do since you don't know exactly how all the pieces might fit together yet but you will usually end up with most of the foundation of what you need. In general though, you should do graphics/UI last because it sits on top of your core functionality. Of course, you need ways to get input and check outputs for testing before you add a UI. So yes, I would ignore the UI first but not use dummy input variables but rather write a general function and unit tests. As for writing formulas, I write the minimum and add variables as I go along. You should remember to keep things as simple and clean as possible. Reduce the number of lines by splitting functions and classes.
<!-- SC_OFF --><div class="md"><p>My background: 2 years of .net development, 1 year of web development.</p> <p>I just talked to a recruiter about some Salesforce dev opportunities he had and I said I wasn&#39;t interested as I didn&#39;t want to be pigeonholed in sf dev and wanted to still expand my skillset in other technologies. His response was, that&#39;s understandable but you will only get a significant raise and career advancement with specialization. I don&#39;t disagree with his position but I feel one you first start out, you should gain some knowledge in a lot of different areas before honing in on one skill.</p> <p>So what do you guys say? At one point should one start focusing on a specific development skill/technology/platform?</p> </div>
http://www.reddit.com/r/cscareerquestions
So you don't know Salesforce, and you say you want to learn new technologies. So you decided not to learn Salesforce?
I do know salesforce...didn't list it in my post, sorry. At my current job i do web development, database design, desktop apps, salesforce dev, etc. It's a great place to learn a lot of different stuff. The jobs the dude was offering me were all salesforce specific, where .net experience was a plus but not a necessity.
ah, okay.
You get the raise/advancement when you handle large things, like a giant migration or developing a large system, or when you hop jobs and negotiate a better salary/title.
<!-- SC_OFF --><div class="md"><p>Just as it says. I&#39;m about to buy some more books and practice some more, but until then... I&#39;m kind of at a loss. I started C++ 3 days ago but I&#39;m transferring my knowledge from JS.</p> <p>What I know right now (I&#39;m sure there&#39;s more but it&#39;s hard to remember everything unless i am put in a situation that calls for a specific purpose):</p> <pre><code>Cout. Cin. Understanding output and extraction operators. Variables. Fundamentals of order of operations. Fundamental types. Fundamental type modifiers. Combined assignment operators. Constants. Relational operators. If statements. If/else if/else if.... Etc. statements. If/else if/else statements. Nesting. For loops. While loops. Do loops. Sequencing events with loops or statements. Switch statements. Implementing **all of the above** together for OOP. break/continue. Logical operators and their presidency. Seeding rand() to start arbitrarily to prevent same series of numbers I.e. De ja vu. Functions. String objects and literals Arrays Enumerators Vectors Iterators Pointers </code></pre> <p>This list goes on and on so I&#39;ll stop for brevitys sake. I think the most complex things I can do right now are polymorphism, classes and inheritance. What goes after that? Any suggestions? Thanks!!!</p> </div>
&gt; I'm kind of at a loss. I started C++ 3 days ... What I know right now I'm curious whether you really &quot;know&quot; every thing of these mentioned. It should take you some efforts and some practice to allow all those things to settle in your head. :) Moreover you are messing some global concepts (like &quot;iterators&quot;) with some minor tricks about some functions usage (like &quot;seeding rand&quot;). also there is nothing said about source files, object files, headers, compilation, linking, using make. these things are not as simple as they may seem initially...
I would agree with this. Do some practice problems (many books will have them, if not, make your own toy problems or google for some). This will test your knowledge and make any shortfalls obvious. ##To OP: In particular, I would think memory management would be a good think to check on (it's an area I see a lot of beginners make mistakes with). Can you create an example of code with a memory leak? How do you fix it? Why does this solve the problem? How can you write code to avoid memory leaks (look up RAII)? Where in memory is an object if I create it with `new`? If I don't use `new`? When is the destructor called? Can I access a variable that points to `delete`d memory? What happens if I don't initialize a new variable? Why does that happen? What happens when I add to a pointer? How are arrays passed to a function? If I have a size 10 array of 4 byte ints and the array starts at memory address 100, what is the memory address of `array[6]`? Some basic language concepts missing from OP's list include function include function pointers (quite important for functional programming) and exceptions (crucial for error handling). You should try and understand why we'd want to pass a function around as a variable and just what exactly the pointer is pointing at. For exceptions, you should understand when you'd want to use them and when you *wouldn't*. Consider how to handle things like resource closure when an exception is thrown. Why would you want to throw exceptions of different types?
**this**. Thank you!!
Thank you! What I intentionally meant was, &quot;what can I do to expand my knowledge after here.&quot;. Thanks for the solid advice.
C++ is a very large and complex language, and you will need a good book (more than one, eventually) to guide you through it. The recommendation here is generally C++ Primer (note not C++ Primer Plus).
Definitely on my list to buy next. I was pretty disappointed that the book store had no copies left. Gotta order it online I guess *shrugs *. I just waiting for shipping lol i would rather have it right in front of me.
I believe you can proceed meanwhile with the info from internet tutorials and examples, rather than waiting :) You know, kind of a loop: 1. read about some new feature (classes, collection types, templates); 2. write some sample test programs to see you understand it and it is working; 3. goto 1.
Do you know about memory allocation? Probably the biggest mistake i often see is that C++'s &quot;new&quot; is not like any other high level language's. You need to manually &quot;delete&quot; any memory you allocate yourself. Second, you know polymorphism, just to make sure. Do you know what a virtual destructor is? Another big mistake i see often is that it isn't used when it should be. Learning assembly might help, though it isn't required i find it can help with some details and also in some instances when you need to debug generated code. It isn't that hard to read once you get the general idea of it. Have you used any templates? One of the reasons C++ is a bit complicated is that templates are pretty much a language of their own inside of C++. They can be hard to read and can get complex pretty quickly when doing anything non trivial. Often times they do make debugging harder by generating crypt error messages. Also curious, why the jump from JS to C++?
Thanks for all the replies everybody! I'm taking all the advice everyone gave and using it.
<!-- SC_OFF --><div class="md"><p>Howdy everyone. I am stuck in a bad way with the beginning of this semester. I have a project due and I need help with it. It involves being able to use a program to see if an input file has lines that contain palindromes of brackets and parentheses. My current work situation forced me to go without tutoring from the university, so now I am on my own. If possible, I could use some one on one help with this assignment and get back up to speed. </p> <p>The project is on this link: <a href="http://cs2.uco.edu/%7Etrt/cs2613/p02.pdf">http://cs2.uco.edu/~trt/cs2613/p02.pdf</a></p> <p>If you want to help, please reply asap and I&#39;ll arrange whatever may be necessary to get me through this. Thank you in advance for your help.</p> </div>
So the assignment is: &gt;Write a program that determines if a string contains a balanced set of brackets. Brackets consist of the pairs ( ), [ ], and { }. A string is a sequence of characters containing no white space. White space is a sequence of one or more blank characters, new line characters, or tab characters. A string is balanced if an opening bracket, (, [, or { is matched by the corresponding closing bracket, }, ], or ). Brackets are matched in a last-in-first-out order. If an opening curly brace, {, appeared in the string then the next bracket in the string must be a closing curly brace }. Any sequence of characters that are not brackets can appear between the opening and closing brackets. Prohibition: Use of the C++ Standard Template Library is prohibited in The page also contains an algorithm written in pseudocode bool isBalanced(const string&amp; candidate) { Stack S; try { for all characters, 𝑐𝑐𝑖𝑖, of string candidate in the range 0 ≤ 𝑖𝑖 &lt; 𝑛𝑛, where 𝑛𝑛 is the number of characters in string candidate do if 𝑐𝑐𝑖𝑖 is an opening bracket, one of ‘(‘, ‘[‘, or ‘{‘ then push it on Stack S; if 𝑐𝑐𝑖𝑖 is a closing bracket, one of ‘)‘, ‘]‘, or ‘}‘ then 1. pop character 𝑐𝑐𝑗𝑗 Stack S and 2. Here 𝑐𝑐𝑖𝑖is the closing bracket and 𝑐𝑐𝑗𝑗 is the opening bracket. Determine if 𝑐𝑐𝑗𝑗 is the corresponding opening bracket for which character 𝑐𝑐𝑖𝑖 is the closing bracket. If 𝑐𝑐𝑖𝑖 and 𝑐𝑐𝑗𝑗 are a matched pair do nothing. If ci and cj are mismatched then return false, indicating that the candidate is not balanced. } catch(StackEmptyException) { return false; } return true if stack S is empty, false otherwise; } These are pretty clear instructions on how to implement the program in question. Now you mentioned you had to go in with no tutoring, does this mean you have no prior experience wiht programming at all?
My previous professor was one that had a completely different style on how teaching and programming in C. His projects consisted of single programs that had all user inputs for the programs (cin). He would tell us that we were free to use outside resources for help and the projects were pretty easy. I didn't learn more than the very basics of the language. I go into this new class and the professor gives us assignments that are tougher, with less time in between, and with strict guidelines; the guidelines involve specific types of compiling and using separate files for the main program. I'm just really lost because he expects us to know all of it before ever walking into the class and refuses to really help us with anything involving compiling or file management. Before, to compile the program in linux, we simply typed $c++ (program name).cpp Now we compile it in linux by using &quot;makefiles,&quot; which he has yet to explain and expects us to know it. The previous professor let us learn on our own and to be creative with our coding, the new one just seems like it's a game of &quot;Ad-libs&quot; or &quot;fill in the blank&quot; but you have no idea what he wants (in terms of how he wants it coded exactly). He wants it an exact way an no way else and it's hard to read his mind. EDIT: The only information I learn for this class and how things are done is from graduate students in the programming tutor lab during 9-5 business hours.
Right, so you have some experience with the basics. The assignment provided does not require any advanced knowledge, you only need to figure out a handful of things 1. How to read/write a file 2. How a String works in C++ 3. How loops work 4. What a stack is an how it works 5. What is a try{}catch{} block 6. How command line parameters work Most likely you're not totally lost on what to do, you're probably just intimidated by how serious the assignment looks. Start off simple, figure out how you can look at the command line parameters in C++. There are plenty of online resources to do that. You can start [here](http://www.cprogramming.com/tutorial/lesson14.html) for example. Once you're one with that start figuring out about files. How to read a file, file buffers, how to write a file, etc. Again there are plenty of resources available e.g [here](http://www.tutorialspoint.com/cplusplus/cpp_files_streams.htm) Now that you know about CLI parameters, and how to red/write files, you're basically halfway done. Next start figuring out Strings. What is it? How it works? How to you read and handle them, etc. Chances are you might even be familiar with them from previous experience. Now you can basically read a file the user specified, and store part of in a string. Now you need to pass the string to the algorithm provided. You have it in pseudocode, so just start figuring out how to implement it, it is pretty straightforward for the most part. After that, you're pretty much done. If you need lots of hand on help, I'd recommend joining the official IRC channel #learnprogramming on Freenode. You can find it on the sidebar, there are plenty of people there willing to help you out. Also, don't be afraid to actually just Google things and find out how shit works. Be prepared to do some research and figure things out yourself. There's nothing wrong with looking for information.
<!-- SC_OFF --><div class="md"><p>Hey all! All the title says. But if you want context....</p> <p>I started off learning in C++, and I fell in love with the #DEFINE statement. It was like a constant, but it didn&#39;t take up any memory!</p> <p>I haven&#39;t found any equivalents since then. I&#39;ve used constants, but I always feel guilty that I&#39;m taking up that tiny bit of RAM, and I find it annoying that I find it pop up as a suggestion when dealing with that class for IDE&#39;s where that&#39;s a problem.</p> <p>I&#39;d also accept any answers reassuring me that using constants is fine, or revealing anything about the #define that I wasn&#39;t aware of. I&#39;m working in AS3 at the moment, but I imagine this knowledge will be useful for just about any language.</p> </div>
&gt; I started off learning in C++, and I fell in love with the #DEFINE statement. You should almost never use #define in C++ code. It's only real use is for include guards, and perhaps in debugging. Certainly you don't want to be using it as you would in C. &gt; It was like a constant, but it didn't take up any memory! Of course it takes up memory! Using macros may well take up _more_ memory than not using them.
[I thought it was all preprocessor stuff?](http://www.cplusplus.com/doc/tutorial/preprocessor/) i.e. substitutes all instances of the #DEFINE constant with the value you define?
First, cplusplus.com is a dreadful resource for learning C++. Second: &gt;substitutes all instances of the #DEFINE constant with the value you define? Why do you think doing this would not take up memory?
Because it only does this substitution before compile time, so it doesn't actually use any memory within the actual program, doesn't it? It'd briefly take up some memory within the preprocessor, I'd imagine.
No, it takes up memory in the program. If you have something like this: #define MEANING 42 int n = MEANING; then MEANING (i.e. 42) will have some sort of representation in the program code wherever it is used.
But wouldn't, after compilation, this: #define MEANING 42 int n = MEANING; become equivalent to this: in n = 42; Otherwise wouldn't it be exactly the same as a constant, but without types and weird namespaces?
That is the code after compilation, but you have not saved any memory over saying: const int MEANING = 42; int n = MEANING; The &quot;weird namespaces&quot; thing is one of the major reasons you should _not_ use macros, as they do not respect namespaces and can very easily clash with other names in your code.
Oh! So are you saying that constants don't require memory after compilation, or are you saying that #DEFINE just gets changed to a constant? I thought that #DEFINE changed the code that the compiler saw to read something else. I don't know why someone wouldn't want that? This is kind of a personal gripe, but if you have a good naming convention, then it won't clash with other names in your code, so not using it kind of seems like fixing the wrong problem. **EDIT:** After reading the other comment I got, it answered my question, validating that it does generate exactly the same code. So it seems 100% pointless to use #DEFINE, ever.
Constants _do_ require memory after compilation, but so does the use of #define. &gt; This is kind of a personal gripe, but if you have a good naming convention, then it won't clash with other names in your code, Trust me - it will.
Constants can be factored out and replaced with their direct value by the compiler, provided that the memory address of the variable is not needed. This is called constant propogation. When this is done, they *don't* require memory after compilation (in the sense that there's no separate variable for the constant -- all places that use the constant will use the constant's value directly).
If you only use the prefix DEF_ and caps for the rest of the value, even in a 1000+ file program, surely there would be zero clashes?
It's not a magic get out of jail free card, it can't magically make things not require memory. For example, if you wrote #define SIZE 100 And then you later wrote for(int i = 0; i &lt; SIZE; i++) { ... } Then that value 100 has to be represented in the program code somewhere. It doesn't just evaporate. In fact, it will take exactly the same amount of memory as: const int num_elements = 100; ... for(int i = 0; i &lt; num_elements; i++) { ... } Assuming that `num_element`'s address isn't taken somewhere, the compiler will be able to treat the above as if you had written `i &lt; 100`, just as in the case of `#define`. These generate *exactly* the same code, except the second one is safer because `num_elements` has scope and type, whereas `SIZE` does not. You should not be using `#define` in C++, and certainly not because somebody erroneously told you that it would save memory.
Ok, I see what you mean. That's really annoying though, because this shouldn't be that hard for a preprocessor to do. I could save a file, do a find-and-replace on 'DEFINE_EQUIVALENT' and replace it with '10', and it would act exactly as I want a #DEFINE statement to do. I would then revert to the old save file after compilation. But that takes a stupid amount of time. This is kind of why I was expecting it to exist in other languages. Apart from it conflicting with naming conventions, I would have thought there's no reason not to use it over a const? I guess scope, but I've always preferred keeping my #DEFINE's in one file, which is just a file for tweaking values. Mind you this is just for things like int, float, bool, etc.
I still don't think you quite get it. The preprocessor works exactly as you wish it to. In the first example, the compiler has no idea that `SIZE` even exists. For all intents and purposes, it sees the file as if you'd written `i &lt; 100`. It's just that it *also* works that way with real variables. The compiler can see the value of a `const int` at compile time, and as long as you never try to take the address of that variable, it can optimize away that variable and pretend that it never existed and that you wrote `i &lt; 100`, just as in the case of the preprocessor. In both cases the value 100 is still stored in the program somewhere, but probably as an immediate encoded directly in an instruction, not as a typical variable. So you're not saving anything by using the preprocessor, and you're only introducing the possibility of a bunch of headaches due to not having a type system to catch mistakes. Edit: and as to why other languages don't generally have a preprocessor, it's because decades of experience show that having a text processor that doesn't understand anything about the semantics of your language sitting in front of your compiler can lead to a vast array of problems. It's generally considered a feature and not a bug to lack a preprocessor of the kind that C and C++ have.
Oh, that's awesome! But does that mean constants aren't calculated before compiling in languages which don't have a preprocessor?
&gt; But does that mean constants aren't calculated before compiling in languages which don't have a preprocessor? No, it doesn't mean that at all. Constant propagation is an important and well-known optimization and has nothing to do with the presence or absence of a preprocessor. The types of optimizations that are performed depend on the particular implementation of a given language. For example, take this C# testcase: static void Main(string[] args) { const int size = 100; for (int i = 0; i &lt; size; i++) { Console.Write('.'); } } In release mode the code generated for this loop is: 001F263C xor edx,edx 001F263E mov dword ptr [ebp-8],edx 001F2641 nop 001F2642 jmp 001F2651 001F2644 mov ecx,2Eh ; '.' 001F2649 call 636547B8 ; Console.Write(Char) 001F264E inc dword ptr [ebp-8] 001F2651 cmp dword ptr [ebp-8],64h ; 64h = 100 001F2655 jl 001F2644 As you can see, it performed the same optimization. `size` doesn't exist as a variable anywhere, and doesn't take up any memory except for the immediate value encoded in the `cmp` instruction, which is unavoidable. I would imagine that something like Java would be similar. The more dynamic the language, the less possible this optimization becomes, or the more difficult it becomes to implement. I wouldn't expect to see much of it in CPython, but perhaps in PyPy.
Ah, ok, thank you! I have absolutely no clue what the code in the second block is, although I could follow along once I squinted at after reading your explanation. I haven't been able to look up what it is called, although I assume it is a much lower level programming language which translates higher level languages.
No, and there's no need for it. You should not feel guilty about using memory. Memory is cheap and trying to make micro-optimizations is the root of all evil. The compiler will usually remove the unnecessary constant, directly replacing the locations that it's used with the constant's value, anyway. In general, you should let the compiler handle small optimizations. Trying to outsmart the compiler can easily make your code slower (compilers are very smart at what they do).
Sounds like solid advice, it's just a curiosity I've had since my #DEFINE days. Do you know if const works the same in AS3?
<!-- SC_OFF --><div class="md"><p>If anyone could recommend some clean, text-based intro to java tutorials, you would be amazing. I&#39;m basically a beginner, though I took an intro to java class around a year ago, which I aced, before life got weird. I can&#39;t stand video tutorials, as I spend more time rewinding and trying to figure out what they just said than actually programming.</p> <p>Also, If anybody could tell me/point me in the direction of what careers are available in the programming field, and what they generally entail, that would be amazing. I&#39;ve been a little overwhelmed trying to figure out what I actually want to do, and it&#39;s stressing me out a little bit. I know I love programming, but I&#39;ve taken too long of a break and I have no idea where to start again, or what to work towards before going back to school in a few months...</p> <p>Thanks so much!</p> <p>P.S. I&#39;ve spent a few hours going around reddit/the internet, and most conversations pertaining to what I&#39;d like to know are either uber specialized to what they&#39;re working towards, or devolve into arguments about the difference between programmers and software engineers. (or the lack there of)</p> </div>
This one I'm doing now is freakin' amazing. http://mooc.cs.helsinki.fi/programming-part1
hey I just started setting all of this up, and it's *exactly* what i needed. Thanks so much!! I'll give you gold when I have a job again. let's see if this works... RemindMe! 2 weeks &quot;This guy needs gold&quot;
Messaging you on [**2015-02-14 07:53:36 UTC**](http://www.wolframalpha.com/input/?i=2015-02-14 07:53:36 UTC To Local Time) to remind you of [**this comment.**](http://www.reddit.com/r/learnprogramming/comments/2u64a5/could_anyone_recommend_some_text_based_java/co6lu6t) [**CLICK THIS LINK**](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[http://www.reddit.com/r/learnprogramming/comments/2u64a5/could_anyone_recommend_some_text_based_java/co6lu6t]%0A%0ARemindMe! 2 weeks ) to send a PM to also be reminded and to reduce spam. _____ [^([FAQs])](http://www.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/) ^| [^([Custom Reminder])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!) ^| [^([Feedback])](http://www.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback) ^| [^([Code])](https://github.com/SIlver--/remindmebot-reddit)
Woah, very kind of you! Also, if you get stuck or want to compare solutions you can always drop me a pm. I'm up to exercise 71 now.
this ones the better for total noobs, mix it up with head first java once you arrived to week 9. That way you will really understand what OOP is about
Thanks! That's looks pretty good
I've been collecting links on learning different programming languages lately -- here's the [section on Java](https://github.com/Michael0x2a/curated-programming-resources/blob/master/resources.md#java). You probably want to skip the &quot;online courses&quot; subsection and jump straight to &quot;books and online tutorials&quot;. I've been trying collect a wide range of materials for people with different learning styles, so you may need to hop around a little before you find a resource you particularly like. Career: It's a little hard to know where to start -- there are so many different careers and paths you can take. I'd normally take a stab at putting together an answer, but unfortunately don't have the time right now. If you want, feel free to pm me a reminder sometime later this week -- I should have more free time and can give a thorough answer. In the meantime, try checking out /r/cscareerquestions and their sidebar+wiki -- they might be able to help with a fair number of your questions.
&gt;Also, If anybody could tell me/point me in the direction of what careers are available in the programming field, and what they generally entail Huge variety. Lots of people are simply &quot;programmers&quot; who write general purpose code for some application. Pretty generic skills. Pretty much every programmer qualifies. Web dev is huge, both backend and frontend. Backend work can be pretty much anything. Front end is mostly JavaScript and very user-event driven. Embedded positions work with low level code, close to the machine. Tons of smaller, more focused fields, often using areas of CS requiring more knowledge.
programmingbydoing.com
The official java tutorial from oracle is pretty good
Indeed. [Link](http://docs.oracle.com/javase/tutorial/getStarted/index.html)
Thanks so much, I'll take a look tomorrow
<!-- SC_OFF --><div class="md"><p>Hi all, idiot beginner here,</p> <p>I&#39;m trying to get a program to do some basic math, essentially it works but it keeps rounding my numbers that are #defined to whole numbers when I&#39;m going for floats. Basically, 25 / 23 keeps rounding to 1 when I need it to be 1.08. Any way of stopping this from happening? Any help is hugely appreciated. Thank you!</p> </div>
https://www.reddit.com/r/learnprogramming/wiki/qtsgfb#wiki_are_you_performing_integer_division_instead_of_floating-point_division.3F
cheers, thank you :D
Defines would never do that; defines are basically a search/replace. What totally would do this 'rounding' is the fact that C does integer division unless you're using doubles. (It's not really rounding, it's truncating. If the answer to x/y was 2.9, then C would say 2.) Cast your arguments to a double. Of course if you divide doubles expect a double in return. If you trying to save a double value as an integer you'll get the same thing: C would case 2.9 to an int by truncating the .9 and giving you 2.
thing is i'm using doubles, the defines are whole numbers set before i even get to int main. Thanks for your help!
<!-- SC_OFF --><div class="md"><p>I&#39;m just starting to learn programming and I&#39;ve been hearing horror stories about techie interviews where they ask a lot of algorithm questions, the whiteboard, etc. How much do I need to know as a Junior Developer? Is there a book or simple videos that will give me the basics or do I need to understand this in depth? It&#39;s not like I&#39;m going to apply for NASA! Thx people.</p> </div>
You learn algorithms as you learn to program so don't worry about them too much now. Algorithms range in simplicity to quite theoretical so it's hard to say what you need to know, since some algorithms are rarely ever used in a job. Junior developer algorithm questions are usually pretty easy, but of course if you end up interviewing with a larger software company they will end up asking much harder questions. Junior positions usually comprise of simple questions (languages, their nuances / differences) and simple &quot;algorithms&quot; (reverse an array/linked list, find the missing number, find unique element in a list, etc). While far, far outside the scope of your current needs of understanding, CSLR is quite the awesome algorithms textbook: http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844
#####&amp;#009; ######&amp;#009; ######&amp;#009; ####&amp;#009; **Introduction to Algorithms, 3rd Edition** Current $75.87 High $84.34 Low $57.19 [Price History Chart](http://i.imgur.com/DYN9ZvF.png) | [Animated GIF](http://i.imgur.com/d6RAczi.gif) | [FAQ](http://www.reddit.com/r/PriceZombie/wiki/index)
Interesting book, I'll check out a book from my local library before digging any deeper. Thank you!
As long as you do not try to re-invent anything, not knowing algorithms is acceptable. So always google to see if there are existing libraries which do what you are trying to do. Computer scientists often have elegant solutions which wise programmers implement into libraries. Bad programmers ignore such accumulated wisdom, and in their arrogance create monstrosities.
I will definitely read more about it, I know nothing about the subject and it makes me feel dumb. :/
<!-- SC_OFF --><div class="md"><p>I feel like this should be a thing. I&#39;m a beginning programmer but every time I make a new class, I make a bunch of instances and put them in an array. I then am always left feeling empty because technically I could just add anything else to this array and everything would be fine. There would be no error. Na&#39; mean?</p> </div>
A traditional array has to have members of the same type so the computer knows how much memory to allocate ahead of time. A collection is a more generic term and it's usually used to refer to classes that collect *things*. Objects, primitive types, whatever. There are collections in most languages that let you add whatever the hell you want to it (Groovy's List, Ruby's array class, C#'s ArrayList being examples). I try to use a collection that has a type associated with it since it's safer and I can catch errors at compile time. Examples are Java's ArrayList&lt;T&gt; class or C#'s List&lt;T&gt; class, where T is a type. Also, everything wouldn't be fine in your example. Let's say you add an instance of a Person class and a String to your array. What happens when you get the firstName property of the instance of Person? That succeeds, right? String, however, doesn't have a firstName property, so if you didn't check for the type before acting on it, the program would throw an exception at that point.
I should have mentioned that my programming experience is pretty much just javascript and php. So I'm a beginner...maybe I should look into these more classical languages.
Those languages actually don't have 'arrays' in the traditional sense, they are lists. Also both JavaScript and PHP are very weakly typed; you can toss anything onto one heap. Most languages have constructs that are either actual arrays and/or use generics that will only allow you to store one type of object in the collections. For example Java, a statically typed language, has both of these. If you define an array of Strings (new String[] { &quot;Apple&quot;, &quot;Pear&quot; }) you won't be able to store anything else in it. The same goes for when you create a set of strings (= new HashSet&lt;String&gt;()): you will only be able to store strings.
You should keep in mind that what an &quot;array&quot; is depends quite a bit on the programming language you're using. It sounds to me like what you're asking for is present in most statically typed languages.
<!-- SC_OFF --><div class="md"><p>I am very interested in programming and web development and I want to go for an associate of science in programming. I am choosing between two community colleges. Which would you guys recommend? </p> <p>I don&#39;t have a formal science or computer background but I did end up learning know , css, and a little bit of php/javascript from starting my own website/business which I built from scratch. I am looking for guidance and advice. I am currently in grad school for something unrelated to computers. My hope is to do the programming and analysis degree online. I am particularly interested in web development but I&#39;ll probably expand to mobile development. How significant of an impact do you think learning online versus in class will have on me learning the material? </p> <p>I am torn between <a href="http://www.sfcollege.edu/ite/index.php?section=web_programming">http://www.sfcollege.edu/ite/index.php?section=web_programming</a> and <a href="http://www.spcollege.edu/courses/program/CWPA-AS">http://www.spcollege.edu/courses/program/CWPA-AS</a></p> <p>Here is the class breakdown the two - </p> <table><thead> <tr> <th>St. Petersburg</th> <th>Santa Fe</th> </tr> </thead><tbody> <tr> <td>Local Area Network Concepts</td> <td>Introduction to College Computing</td> </tr> <tr> <td>Introduction to Computer Programming</td> <td>Web Authoring 1</td> </tr> <tr> <td>Computer Operating Systems</td> <td>Programming Logic</td> </tr> <tr> <td>Web Foundations/Essentials</td> <td>Professional Development</td> </tr> <tr> <td>Systems Analysis and Design</td> <td>Web Authoring 2</td> </tr> <tr> <td>SQL Database Design &amp; Programming</td> <td>Introduction to Programming</td> </tr> <tr> <td>JavaScript</td> <td>Database Management</td> </tr> <tr> <td>Advanced Web Site Development</td> <td>Microcomputer Architecture 1 or Linux Administration</td> </tr> <tr> <td>Web Scripting with CGI/PERL</td> <td>Internet Programming</td> </tr> <tr> <td>Developing Web Sites Using PHP/MYSQL</td> <td>Graphics Apps</td> </tr> <tr> <td>Introduction to C# Programming</td> <td>SQL Programming</td> </tr> <tr> <td>Advanced Programming with C#</td> <td>Object Oriented Programming 1</td> </tr> <tr> <td>ASP.NET Programming with C#/VB.NET</td> <td>Advanced Website Development</td> </tr> <tr> <td>Advanced PHP/MySQL</td> <td>Object Oriented Programming 2</td> </tr> <tr> <td>Internship</td> <td>Intro to Java and Android Programming</td> </tr> <tr> <td>nothing</td> <td>Internship</td> </tr> </tbody></table> </div>
If I had to choose one I'd probably go to Santa Fe.
Would you mind elaborating why you think that program is better?
I guess mostly just based on the real-world application I perceive in it. Little more well rounded I suppose but it's nothing solid I can state to pick it over the other.
Gotcha. Appreciate the input!
St. Petersburg with the C#/Open source subtrack. I think that will set you up for a better programming foundation than Santa Fe.
Thanks.
<!-- SC_OFF --><div class="md"><p>I&#39;m creating a course to teach beginners Web Development with Ruby on Rails. It will cover all the <em>essential</em> topics a beginner needs to know to create a first web app. The course will contain interactive challenges, cartoons and diagrams to make the learning engaging! The cartoons will represent Ruby on Rails as a physical machine so beginners can &quot;see&quot; how Rails works. You can view early drafts of my cartoons at the links here: <strong><a href="https://www.learneroo.com/modules/3/nodes/608">Interactive Cartoon Guide to Ruby on Rails</a></strong></p> </div>
<!-- SC_OFF --><div class="md"><p>Hi guys!</p> <p>Im a 14 years old teenager and im from Uruguay, i wanted to post this because i don&#39;t have any friend to talk with about programming and sutff. The thing is i love videogames, specially old school ones, i know im just 14 but i&#39;ve played NES games (8-bit videogames if im no mistaken haha) and i love them, i watched videos such as AVGN and other gamers that plays old video games, i love them, i really do.</p> <p>In Uruguay ( I don&#39;t know if in other countries too ) once you complete 3 years in high school you can choose wich way you can go, and with way i mean art, music, science, IT, etc. , so i only need to do 2 more years in high school to take the path for programming. Well now i explain why im posting this. I am really excited about all of these, i love computers and all that stuff, my brother is a math teacher and in college he needed to use a program called Python, i think it is also a programming lenguage, i helped him using it and i learned a looot about it. I programmed a quiz game once. A few months ago i read plenty of things about which is the best programming lenguage for the things i like, so i&#39;ve heard that c++ works fine with almost everything but lua is pretty much like python so i didn&#39;t know that to do. Knowing that i watched tutorials on YouTube about programming, but most of them only had 2 episodes where they don&#39;t explain anything, they just say &quot;oh that is too complicated i will teach you that in other episode&quot; and they just stop making videos. Thats where i started giving up on start to learn programming, i was very very excited so i was very sad for like 2 weeks. So 2 months later i discovered reddit, where i find people that could help me on problems that no one i ever met could. So then i said to my self, is there a subreddit for programming? And i found it! So here i am, asking you guys should i learn to program? should i spend my time learning to, and how do i learn to, wich program lenguage should i learn?</p> <p>And thank you for spending your time reading all of that and im sorry if i had grammar errors, i hope you understand how im feeling about all of this.</p> </div>
No one can answer your question except for you. If you enjoyed making the quiz game, then why not learn more? Personally I would not start with C++. I'd start with C or Python. There are plenty of tutorials around for both, check the FAQ for them. In the end, it's your choice. Do what makes you happy. Life is too short to do otherwise.
But if i jump from one programming lenguage to the other, will it be hard to?
Probably. But the only things worth doing in life are things that are hard to do! You know, like playing guitar. Playing football. Painting. Math. Writing. The trick is finding something that you like, that really clicks for you. That won't make it any easier, it just means you'll be enjoying it while it is hard to do.
&gt; the only things worth doing in life are things that are hard to do now, now, there are plenty of easy things that are worthy too.
Of course there are. They just aren't the things that give you this huge sense of accomplishment and a sense of purpose in the world. Watching a great movie is worth doing but you don't pat yourself on the back for it. *Making* a great movie, on the other hand.
Oh, yes, indeed.
No one is advocating you jump from language to language at this early state (and I certainly did not advocate such in my reply). You definitely need to pick one language and stick with it for a while, I just do not think this should be C++. If you like Python, then pick Python. There are a ton of tutorials out there on it, as others and the FAQ have said. Do not jump on a new language until you feel you have outgrown the one you are learning. Jumping languages in a beginner state will just confuse you. As an example, I said I want to make games but I have never programmed before I started taking a class online. Obviously not a lot of games are done in C anymore (although some still are) and most are done in C++ or Python or C# or Java. But, C can be considered an ancestor of those languages and I found a great course on edx.org called CS50 that teaches C. So, I decided to start with C just based on the availability of that course and the fact I can create a foundation to learn other languages I will need later. Would I save time just starting with C++ or Python or Java? Maybe so, but also maybe not. You gotta learn to crawl before you can walk. In my situation C is learning to crawl. C++ is learning to run 5k marathons. Get the picture? ;-) So there you go, pick a language you like, find a tutorial you like, and study hard in math and you're all set!
What about lua? I heard its like Python.
&gt; should i learn to program? No. If you don't want to learn programming, that'll make it easy for you. If you want to learn programming, then asking me if you should is nonsensical and if you have a spine you're going ignore me anyway.
I like this answer. It sounds harsh, but it actually motivates even more than a simple &quot;yes, do it, it's great&quot;.
Honestly I think it is dependent on what YOU want to do. I am a CS major about to graduate in May. I love programming. I not only do it for school work, but also in my free time. This is key. Programming can be very difficult and frustrating sometimes. I know plenty of kids who signed up for a Computer Science major, only to learn that 2 semesters in they didn't like it or couldn't handle it. I'm not sure about Uruguay, but in my experience, CS is a lot of Math and a lot of problem solving. If that is what you are into then I would say go for it. On a more positive note, knowing how to program can be very powerful. Obviously tech industry is booming at the moment and people who can write scripts/programs are very valuable. My suggestion would be to look into websites like [learnpython](http://www.learnpython.org/) and [Codeacademy](http://www.codecademy.com/en/tracks/python) to get a good start on programming. These sites are by no means a 100% way to learn programming, but they are a decent start. If you complete some of the tutorials and decide you like it then you can move on to other things. In the end I think you should spend some free time doing some scripting/programming. If you decide that you like it then absolutely. With that being said, getting a degree in something like Computer Science is no easy task. So you should also keep that in mind.
Thank you so much, i didn't know about learnpython and codeacademy, i will be completing some tutorials and then i'll se what to do next :)
Just try to learn, if you try you'll know if you like. And then you can keep going.
absolutely yes.
Yes!